\def\classname#1{\texttt{#1}}

\chapter{Atividades Realizadas}
\label{sec:atividades}

  O objetivo desse capítulo é relatar as diversas atividades realizadas no
  planejamento e desenvolvimento do Projeto Ouroboros. Como ele é anterior ao
  nosso trabalho de formatura, descrevemos também as atividades dos anos
  anteriores. Explicamos como de fato implementamos a solução apresentada no
  capítulo anterior, as dificuldades técnicas encontradas e todos os outros
  recursos que utilizamos para concretizar nossa ideia.
  
  \section{Origem do projeto}
  \label{sec:atividades:origem}
  
    %TODO "estes que vos escrevem"
    %TODO Essa seção precisa ser beeeeeem mais detalhada.
    A proposta desse projeto foi elaborada no início deste ano, para o nosso
    trabalho de formatura supervisionado. No entanto, o sistema em si já havia
    sido desenvolvido por nós desde o começo de 2011. Ele era parte da UGDK, uma
    \emph{engine} de desenvolvimento de jogos eletrônicos bidimensionais (ou
    simplesmente jogos 2D) programada pela equipe USPGameDev, da qual
    fazemos parte\footnotemark. Nós desenvolvemos a porção que corresponde ao
    % "ao sistema atual" significa o quê?
    sistema atual quando acreditamos que seria útil que quem estivesse usando a
    UGDK pudesse facilmente integrar seus jogos com \script{s}.

    \footnotetext{
      O USPGameDev é um grupo de pesquisa e desenvolvimento de jogos da
      Universidade de São Paulo. A UGDK é um de seus principais projetos, e seu
      nome é um acrônimo que pode significar tanto \emph{USP Game Development
      Kit} quanto \emph{USPGameDev Kit}. Ela é desenvolvida em \CXX{}. Ver
      \url{uspgamedev.org} (última visita em 25/07/2013).
    }

    Mais especificamente, queríamos que essa integração fosse possível em um
    outro projeto, também do USPGameDev: o jogo eletrônico chamado \emph{Horus
    Eye}\footnotemark. Trata-se de uma aplicação feita em \CXX{} que usava os
    recursos da UGDK para construir os alicerces do jogo. A equipe estava tendo
    muitas dificuldades em expandir o conteúdo dele desde o seu lançamento em
    outubro de 2010, pois não só apenas os membros mais antigos sabiam programar
    em \CXX{}, como também só eles sabiam \emph{o quê} precisava ser mudado para
    obter os resultados desejados. O então chamado ``sistema de \script{s} da
    UGDK'' foi a solução que propomos.

    \footnotetext{
      Ver \url{uspgamedev.org/horus-eye} (último acesso em 25/07/2013)
    }

    Ele fornecia ferramentas que buscavam simplificar o máximo possível a
    troca de dados do jogo com arquivos de \script{}. Bastava isolar as
    partes mais críticas para a elaboração de conteúdo novo do jogo de maneira
    que elas pudessem ser programadas majoritariamente através de \script{s}. E
    dessa maneira tornamos possível aprimorar o jogo usando linguagens bem mais
    simples que \CXX{} e sem a necessidade de conhecer todas as minúcias do seu
    código.

    %TODO colocar imagens do horus antes e depois do sistema de scripts

    %
    %Dessa maneira, surgiu a ideia inicial de programar um conjunto de
    %funcionalidades capaz de facilitar a comunicação entre uma linguagem compilada
    %(\CXX{}) e uma linguagem de \script{}. No entanto, não conseguimos chegar
    %imediatamente a um consenso sobre qual linguagem de \script{} usar
    %especificamente. As mais comunmente conhecidas na área de desenvolvimento de
    %jogos eletrônicos são Lua e Python. Então de um lado tínhamos as vastas
    %extensões e facilidades de Python, e do outro a simplicidade minimalista e
    %versátil de Lua. O melhor jeito de resolver o impasse foi usar ambas.
    %
    %Isso levou ao então chamado "sistema de \script{s} da UGDK": um sistema que
    %premite que o desenvolvedor-usuário carregue módulos do seu jogo a partir de
    %\script{s} sem que ele tenha que se preocupar em determinar e tratar a linguagem
    %de origem deles. Com a ajuda de uma ferramenta que descobrimos nessa época
    %chamada SWIG, consequimos completar uma versão inicial do sistema de \script{s},
    %que existe até hoje no código da UGDK\footnote{Há planos para a UGDK usar
    %diretamente o sistema do Projeto Ouroboros quando ele estiver pronto,
    %abrindo mão do atual sistema de \script{s} próprio dela}.
  
  %\classname{UmaClasse} 
  %
  %\begin{codebox}
  %    \Procname{$\proc{XTR-mul}(x, y)$}
  %    \zi $\id{temp} \gets x_1 * y_2 + x_2 * y_1$
  %    \zi \Return $\proc{XTRElem}(x_2 * y_2 - \id{temp}, x_1 * y_1 -
  %    \id{temp})$
  %\end{codebox}

  \section{Decisões de projeto}
  \label{sec:actividads:decisoes}
  % TODO: checar toda essa seção (e sub-seções) por erros, e provavelmente
  %       tem que arrumar um monte de coisa pra indicar o que é ou onde 
  %       encontrar essas ferramentas (como CMake, Git, etc).
  Quando começamos a desenvolver o nosso ``sistema de \script{s}'',
  como ele era integrado à UGDK e fazia parte do USPGameDev, muitas das
  nossas decisões do projeto refletiam os padrões de projeto que seguíamos
  no grupo.
  
  Escolhemos \CXX{} como a linguagem de programação a ser usada para desenvolver
  o sistema pois essa era a linguagem que a UGDK e os nossos jogos usavam, 
  e além disso é comum linguagens de \script{} terem uma implementação de 
  sua máquina virtual para \C{}, ou até \CXX{}, ambas das quais podemos 
  usar facilmente no \CXX{}.
  
  Também decidimos inicialmente que o sistema seria generalizado para poder
  funcionar com possivelmente qualquer linguagem de \script{}, sendo que
  inicialmente iríamos incluir suporte à Lua (a qual o Wilson conhecia bem)
  e Python (usada regularmente pelo Fernando). Para prover a geração de 
  \textit{wrappers}, escolhemos o SWIG, que foi a melhor opção para o que 
  necessitávamos segundo nossa pesquisa (o que essa ferramenta faz e como
  usamos ela será melhor explicado mais adiante, na seção \ref{sec:actividads:integracaoswig}).
  
  Como os projetos do USPGameDev usavam CMake para simplificar sua compilação
  em diversas plataformas e compiladores, nós também usavamos essa ferramenta.
  Usualmente progamávamos em Linux (Debian ou Ubuntu) usando \lang{G++} como compilador,
  ou em Windows com o Visual Studio 2010. Para controle de versão do código fonte
  usamos o mesmo repositório da UGDK, que usava Git, hospedado no GitHub.
  
  \subsection{Mudanças no Projeto para o Trabalho de Formatura}
  Quando começamos o trabalho de formatura, fizemos algumas mudanças nas nossas
  decisões de projeto originais.
  
  Primeiramente, separamos o sistema para ser um projeto separado, totalmente
  independente de qualquer outro projeto do USPGameDev, e o nomeamos Projeto
  Ouroboros. Partindo do código de fonte original, criamos outro repositório
  Git específico para o Ouroboros, ainda hospedado no GitHub.
  
  Também decidimos atualizar a linguagem de programação usada para \CXX{11},
  uma versão bem mais recente do \CXX{} clássico, com diversas melhorias e
  novas funcionalidades. Isso introduziu um problema no projeto: qual compilador
  poderíamos usar. Como o \CXX{11} ainda é razoavelmente recente, nem todos
  compiladores reconhecem todas suas novas funcionalidades. Mais notavelmente,
  não conseguimos mais compilar no Windows com o Visual Studio 2010, e nem com
  sua versão mais recente, Visual Studio 2012. No Linux, tivemos que usar uma
  versão mais recente do \lang{G++}, a 4.7. Enquanto existem versões ainda mais 
  recentes, essa era a mínima que necessitamos, e ela não é padrão dos repositórios
  %melhorar essa parte... ta meio estranho essa coisa do g++
  de pacotes do Ubuntu estável atual, tivemos que atualizar o \lang{G++} separadamente.
  
  Como parte do trabalho de formatura, tiramos o SWIG do projeto para substituí-lo
  pelo nosso gerador de \textit{wrappers}, o OPWIG (mais sobre ele na seção 
  \ref{sec:actividads:opwig}). Também passamos a criar e usar bem mais testes
  unitários para testar o nosso código, além de registrar nosso repositório Git
  no Travis\footnotemark, que automaticamente tenta compilar nosso projeto e
  rodar todos os testes.
  
  \footnotetext{
    O Travis (\url{https://travis-ci.org/Rewasvat/ouroboros/}) é um servidor de 
    integração contínua: ele automaticamente baixa seu repositório quando há
    alguma mudança nele, e executa uma sequência de comandos determinada pelo
    usuário através de um arquivo no repositório.
  }
  
  Nossa metodologia de trabalho também foi alterada. Passamos a desenvolver o
  sistema separadamente do USPGameDev, manter listas de tarefas pendentes e a
  ter objetivos fixados periodicamente para serem completados o quanto antes.
  
  \section{Uma interface comum para Lua e Python.}
  \label{sec:atividades:opa}
  Desenvolver uma interface comum entre as duas linguagens de \script{} foi uma das 
  primeiras coisas que fizemos, e hoje o trabalho realizado nesse quesito foi o que
  formou a \emph{Ouroboros Project API} (OPA). Desde o começo já desenvolvemos uma
  interface generalizada capaz de usar uma ou outra linguagem de \script{} sem
  diferenças na interface para o usuário.
  
  % TODO: Aqui começa se referindo à (classe) VirtualOBj no femenino. Mais
  %       adiante, refere-se ao (objeto) VirtualObj no masculino. Precisamos
  %       bolar um jeito de deixar isso mais consistente e menos discordante.
  %       (discordância de gênero é um erro de português)
  \subsection{\VObj{}}
  \label{sec:atividades:opa:vobj}
  A principal classe dessa interface comum é a \VObj{}. Essa classe 
  encapsula um objeto qualquer de uma máquina virtual, podendo representar um
  módulo de \script{} carregado, uma instância de uma classe, um valor na máquina
  virtual, entre outros. É praticamente a única classe que o usuário precisa 
  usar. Ela implementa alguns métodos que possibilitam ao usuário realizar 
  operações comuns a qualquer linguagem de \script{} sobre o tal objeto, e 
  também sobreescreve alguns operadores de \CXX{} para facilitar o uso de 
  algumas operações, como por exemplo:
  \begin{itemize}
    \item Executar o objeto como uma função: simplificado pelo operador \lang{()}
      do \CXX{}, permitindo você usar o próprio \VObj{} como uma função. Exemplo:
      \begin{lstlisting}
        VirtualObj vObj, vReturnObj, vObjArg1, ... vObjArgN; 
        VirtualObj::List vObjList; // <=> std::list<VirtualObj> vObjList
                                   // lista de VirtualObj.
                                   
        vReturnObj = vObj();
        vReturnObj = vObj( vObjArg1, vObjArg2, ... , vObjArgN );
        vReturnObj = vObj( vObjList );
      \end{lstlisting}
    \item Acessar e alterar atributos do objeto: simplificado pelo operador
      \lang{[]} do \CXX{}, permitindo você usar o próprio \VObj{} como uma
      tabela de símbolos. Exemplo:
      \begin{lstlisting}
        VirtualObj vObj, vAttrObj, vObj_AttrName;
        vAttrObj = vObj["nome_do_atributo"];
        vAttrObj = vObj[ vObj_AttrName ];
      \end{lstlisting}
    \item Executar um método do objeto (instância de uma classe): simplificado pelo
      operador \lang{|} do \CXX{}. Chamadas de métodos em linguagens de \script{} normalmente
      passam a instância da classe (o próprio objeto) como o primeiro argumento da
      função, e o uso desse operador com o objeto simplifica essa operação. Exemplo: 
      \begin{lstlisting}
        (vObj | "nome_do_metodo")( /*argumentos como nas chamadas de funcao*/ );
      \end{lstlisting}
    \item Conversão de valores: como a maioria dos métodos (e operadores) do
      \VObj{} recebe e retorna outros \VObj{}s, a conversão de valores é o que forma a
      principal ponte entre objetos de \CXX{} e objetos da máquina virtual. Para tanto, o \VObj{}
      possui 2 métodos \textit{templates} que possibilitam a conversão de valores entre
      os dois ambientes. Exemplo:
      \begin{lstlisting}
        T* valor = vObj.value<T*>();
        vObj.set_value<T*>(valor);
        
        VirtualObj vNumObj; //suponha um VirtualObj contendo um numero
        double num = vNumObj.value<double>(); // pegar o valor
        vNumObj.set_value<double>(num);       // atribuir o valor
      \end{lstlisting}
  \end{itemize}

  \begin{framed}
    \textit{Templates} são uma funcionalidade de \CXX{} que permite
    criar funções e classes genéricas, recebendo 1 ou mais tipos\footnotemark{} em uma notação especial,
    que a função ou classe usa de forma genérica em seu corpo. Exemplo de chamada de uma
    função \textit{template}:
  \begin{verbatim}
    função_genérica<tipo1, tipo2, ...>(argumentos);\end{verbatim}
  \end{framed}
  
  \footnotetext{
    \textit{Templates} também podem receber valores aritméticos e \str{s},
    mas na interface do \VObj{}, e na maioria do nosso trabalho, somente usamos com tipos.
  }
  
  Na prática, o \VObj{} é uma classe que encapsula um \VData{}. Todas essas operações do
  \VObj{} são repassadas para seu \VData{}\footnotemark. Esta classe, que representa um objeto numa máquina
  virtual específica, não deve ser usada diretamente pelo usuário. Para isso existe o
  \VObj{}. Mais sobre o \VData{} pode ser visto na subseção \ref{sec:atividades:opa:vdata}
  
  \footnotetext{
    Esse é um padrão de projeto específico de \CXX{} conhecido como
    \textbf{ponteiro para implementação}.
  }
  
  \subsection{\SMgr{}}
  \label{sec:atividades:opa:smgr}
  Mas agora como que o usuário cria \VObj{s}? De algum lugar tem que vir os primeiros \VObj{s}, relativos
  aos módulos de \script{} carregados. É ai que entra a segunda principal classe dessa interface comum
  entre linguagens, e praticamente a única outra classe que o usuário precisa usar além dos \VObj{s}:
  o \SMgr{}.
  
  O \SMgr{} é uma classe que segue o padrão de \textit{singleton} e gerencia as máquinas virtuais que
  estão disponíveis no sistema, permitindo ao usuário executar algumas operações simples porém 
  importantes nelas como um conjunto:
  
  \begin{framed}
    \textit{Singleton} é um padrão de projeto que permite ter apenas uma instância de uma classe
    num dado momento.
  \end{framed}
  
  \begin{itemize}
    \item Inicialização e Finalização: o \SMgr{} tem métodos para inicializar e finalizar o conjunto
      de máquinas virtuais. A inicialização é necessária para poder usá-las e também serve para
      especificar o diretório na qual \script{s} serão carregados pelo \SMgr{}, e a finalização 
      termina as máquinas, liberando quaisquer recursos do computador que elas estejam usando. Exemplo:
      \begin{lstlisting}
        //SCRIPT_MANAGER() eh uma macro que retorna um ponteiro para a instancia do ScriptManager.
        bool ok = SCRIPT_MANAGER()->Initialize("./caminho/para/os/scripts/");
        
        SCRIPT_MANAGER()->Finalize();
      \end{lstlisting}
      Se o valor booleano que o \lang{Initialize} retorna for verdadeiro, o \SMgr{} foi inicializado
      sem problemas. Caso contrário ocorreu algum problema na inicialização dele.
    \item Registro e busca de máquinas virtuais: o \SMgr{} inicialmente não sabe quais são as máquinas
      virtuais disponíveis. O usuário pode tanto registrá-las manualmente com um simples método, quanto
      delegar essa responsabilidade para o código gerado pelo OPWIG, como veremos mais adiante.
      Caso seja necessário, ele pode buscar uma máquina virtual registrada. As máquinas virtuais
      são representadas no nosso sistema pela classe \LangWrap{}, que é uma classe abstrata,
      devendo ser implementada para cada máquina virtual. Exemplo:
      \begin{lstlisting}
        //Registrando uma maquina virtual.
        LangWrapper* vm = new python::PythonWrapper();
        SCRIPT_MANAGER()->Register(vm);
        
        //Buscando uma maquina virtual.
        LangWrapper* pyvm = SCRIPT_MANAGER()->GetWrapper("Python");
        // pyvm sera equivalente ao vm declarado antes.
      \end{lstlisting}
    \item Executar código: o \SMgr{} permite ao usuário executar um código qualquer, dado como uma
      cadeia de caracteres, na máquina virtual de sua escolha. Exemplo:
      \begin{lstlisting}
        SCRIPT_MANAGER()->ExecuteCode("Linguagem", "codigo em tal linguagem");
      \end{lstlisting}
    \item Carregar módulos: possivelmente o método mais importante do \SMgr{}, este método recebe
      um caminho para um \script{} (sem a extensão de arquivo). Ele então determina se o \script{}
      existe, e de acordo com a extensão do arquivo, qual máquina virtual deve rodá-lo. A tal máquina
      virtual então carrega o \script{} e a função retorna um \VObj{} representando o módulo em
      sua linguagem de \script{}. Exemplo:
      \begin{lstlisting}
        VirtualObj modulo = SCRIPT_MANAGER()->LoadModule("modulo");
        VirtualObj modul2 = SCRIPT_MANAGER()->LoadModule("pacote.subpacote.modulo");
      \end{lstlisting}
  \end{itemize}
  
  \subsection{\LangWrap{}}
  \label{sec:atividades:opa:langwrapper}
  O \LangWrap{} é uma das duas classes abstratas do sistema que devem ser implementadas para
  cada linguagem para que ela consiga ser usada pelo OPA. O \LangWrap{} representa a máquina
  virtual da linguagem em si, sendo usada internamente pelo \SMgr{}. Raramente ela será
  usada diretamente pelo usuário. Alguns métodos importantes de sua interface são:
  
  \begin{itemize}
    \item Inicialização e Finalização da máquina virtual. São chamados pelo \SMgr{} internamente.
    \item Método para retornar a cadeia de caracteres correspondente à extensão de um 
      arquivo de \script{} dessa linguagem.
    \item Carregar módulos, chamado pelo \SMgr{} internamente.
    \item Executar código arbitrário, também chamado pelo \SMgr{}.
    \item Retornar um novo \VData{} (ver próxima seção) vazio correspondente a essa linguagem
      (uma instância vazia da classe que implementa o \VData{} para esta linguagem).
  \end{itemize}
  
  \subsection{\VData{}}
  \label{sec:atividades:opa:vdata}
  \VData{} é a segunda classe abstrata do sistema que deve ser implementada para uma linguagem
  de \script{} poder ser usada pelo OPA. Ela representa um objeto contido na máquina virtual
  de uma linguagem específica.
  
  Essa classe é uma interface para métodos que devem implementar todas aquelas operações do 
  \VObj{} (descritas anteriormente), de tal jeito que o \VObj{} chama essas funções na implementação
  de seus métodos e operadores. Dessa forma, um \VObj{} pode ter um \VData{} de uma linguagem 
  ou de outra sem se preocupar de qual é, graças ao polimorfismo através de herança.
  
  Fora métodos para as operações descritas na subseção \ref{sec:atividades:opa:vobj}, um ponto
  importante da interface do \VData{} é um método para retornar a instância (contida no \SMgr{}) 
  da implementação do \LangWrap{} que representa a máquina virtual responsável por esta instância
  de \VData{}.
  
  
  \section{Integração com SWIG}
  \label{sec:actividads:integracaoswig}
  O \emph{Simplified Wrapper and Interface Generator} (SWIG\footnotemark{}) é uma ferramenta
  para exportar uma interface \C{}/\CXX{} para diversas linguagens de \script{} de alto nível.
  Um dos usos padrão dessa ferramenta (e a forma como usamos) é gerar o código de \textit{wrapper}
  necessário para criar módulos em linguagem nativa para uma determinada linguagem de \script{}.
  E é isso que possibilita tal linguagem ter acesso a uma interface implementada em \CXX{}.
  
  \footnotetext{Disponível em: \url{http://www.swig.org/} (data de acesso: 2 de setembro de 2013).}
  
  Usamos o SWIG pois enquanto nossa interface comum, o OPA - definido na seção anterior -, 
  possibilita que o \CXX{} use linguagens de \script{}, também precisávamos de algo para que linguagens 
  de \script{} tenham acesso a interfaces \CXX{}. Após pesquisar possíveis soluções encontramos
  o SWIG, uma ferramenta já um tanto quanto antiga e usada na indústria que fazia basicamente o
  que queríamos.
  
  Como o SWIG é uma ferramenta já pronta, e que é executada para gerar código que será compilado
  com o código do usuário, a integração entre ele e o nosso sistema é bem simples. A principal
  integração está no fato que o OPA usa uma interface padrão (para cada linguagem de \script{})
  gerada pelo SWIG para conseguir converter instâncias de tipos do usuário entre \CXX{} e as
  máquinas virtuais.
  
  % TODO: Exemplos (de como usar o swig)!
  O SWIG usa arquivos separados, seguindo a interface deles, para determinar quais arquivos
  de \CXX{} ele irá ler, e como irá gerar o \textit{wrapper} para tal código. Nesses arquivos
  de interface do SWIG é também possível incluir código que será posto no código gerado, ou usado
  internamente no código gerado em algumas etapas, como por exemplo nas conversões de valores
  que existem nos \textit{wrappers}. O segundo grupo de integrações com o SWIG que fizemos está
  nesses arquivos.
  
  Fizemos algumas coisas com diversos objetivos nesses arquivos de interface, mas podemos
  classificá-las de dois jeitos:
  \begin{enumerate}
    \item Código usado para dizer para o OPA quais são os tipos de usuário exportados para
      as máquinas virtuais, e as estruturas de dados do SWIG que representam eles. O OPA
      por sua vez necessita disso para poder converter tais tipos entre a máquina virtual
      e o \CXX{}.
    \item Código usado para mudar ou adicionar alguma funcionalidade ao \textit{wrapper}
      gerado. Tais códigos essencialmente tentam resolver algum problema do SWIG, como
      a incapacidade de herdar tipos de \CXX{} nas linguagens de \script{}. Veremos mais
      sobre esses problemas na próxima seção.
  \end{enumerate}
  
  
  \section{Problemas com SWIG}
  Ao longo do tempo em que fomos usando o SWIG notamos alguns problemas com ele, que eram
  refletidos no nosso sistema, impondo certas restrições. Alguns desses problemas conseguimos
  apaziguar com código posto nos arquivos de interface do SWIG, como mencionado na seção
  anterior.
  
  \begin{itemize}
    \item A determinação de \textit{disown} depende da API do usuário e não é prático usar.
      \textit{Disown} é o ato de fazer com que algum método da interface \CXX{} retire a posse
      de uma instância de uma classe \CXX{} que ele recebe como argumento da máquina virtual. 
      Quando a máquina virtual cria algum objeto \CXX{}, ou seja, um objeto da linguagem de 
      \script{} que encapsula uma instância de alguma classe \CXX{} que foi exportada, ela
      retém a posse de tal objeto. Quando a ela for remover tal objeto de \script{}, seja 
      lá por qual razão, se ela deter a posse do objeto, ela também irá remover a instância 
      \CXX{} encapsulada. Isso pode causar problemas se alguma parte do código \CXX{} tem 
      algum ponteiro para tal instância, e tenta remover ou simplesmente usar ela em algum
      momento após a máquina virtual ter removido a instância. Portanto fizemos que métodos
      da interface \CXX{} que recebem instâncias de classes e cuidam da remoção delas 
      internamente tiram a posse de tal instância da máquina virtual.
      % TODO: Faltou falar mais sobre o verdadeiro problema: a impraticidade do design do
      %       SWIG em reconhecer essas especificações. A questão da posse em si é
      %       inerente ao problema, e não tem como ser evitada.
    \item O SWIG não tem suporte a classes, \textit{structs} e \textit{unions} aninhadas, e 
      aparentemente não pretende ter tão cedo. Aninhar tais estruturas de \CXX{} é o ato
      de definir algumas delas dentro de outra.
    \item SWIG não tem suporte a herança de classes \CXX{} nos \script{s}. A nossa ``solução''
      para isso foi criar um sistema de \textit{proxies}\footnotemark: classes \CXX{} que derivam de uma
      classe base \textit{proxy} e da classe ``alvo'' \CXX{} que foi exportada para \script{}.
      Essas classes \textit{proxy} contém um \VObj{} com um objeto de script que deve ser uma
      instância da classe de \script{} que derive da classe \CXX{}. Elas também implementam 
      os métodos virtuais da classe base, usando o \VObj{} para repassar a chamada do método
      para o objeto virtual. Fora a definição da classe \textit{proxy} base, e das \textit{proxy}
      para cada classe \CXX{} passível de ser herdada, para esse sistema funcionar foi também
      necessário uma grande parte de código adicionado nos arquivos de interface do SWIG.
      
      \footnotetext{Uma alternativa para simplificar esse processo está no nosso blog: 
        \url{http://projeto-ouroboros.blogspot.com.br/2013/07/gerador-de-proxies.html}}
      
    \item O SWIG não exporta em seus \textit{wrappers} variáveis e métodos de classes com 
      modificador de acesso \textit{protected} (acessíveis somente pela classe em si e por 
      classes derivadas). Isso decorre do fato que ele não tem suporte a herança, como mencionado
      anteriormente, mas ainda assim é um problema ao nosso ver.
    \item Problemas com \textit{wrappers} de Lua:
      %TODO: WIL! Acho que essa parte vc deve ver direito...
      \begin{itemize}
        \item Uma das informações necessárias (metatabelas das classes) só pode ser obtida
          fazendo suposições sobre a implementação interna dos \textit{wrappers} de Lua do SWIG.
        \item Duas funções internas dos \textit{wrappers} de Lua do SWIG precisam ter uma linha
          de código alterada para que \textit{proxies} funcionem.
      \end{itemize}
  \end{itemize}
  
  \section{Nosso próprio gerador de \emph{wrappers}}
  \label{sec:actividads:opwig}
  Boa parte do que explicamos nas seções anteriores neste capítulo foi o trabalho que realizamos
  antes do trabalho de formatura. E o principal ponto do trabalho é exatamente o de substituir 
  o SWIG por uma ferramenta própria que criamos, a fim de simplificar o uso e corrigir os
  erros listados na seção anterior. Mantemos o OPA, fazendo algumas alterações para resolver
  erros, melhorar o sistema ou substituir as partes relativas ao SWIG para a nossa nova ferramenta.
  
  Foi então que surgiu o nosso próprio gerador de \textit{wrappers}, o \emph{Ouroboros Project 
  Wrapper and Interface Generator} (OPWIG).
  
  Enquanto o OPWIG ainda não é capaz de substituir completamente o SWIG, ele já realiza algumas
  tarefas básicas importantes, como exportar funções, variáveis e classes simples. E continuamos
  o seu desenvolvimento num passo constante razoável. Infelizmente não podemos ainda falar que
  já conseguimos resolver os problemas do SWIG pois como nossa ferramenta ainda está no começo
  do desenvolvimento, ainda não chegamos no ponto de ocorrer tais erros. 
  
  Mas pelo menos já conseguimos notar que será relativamente fácil corrigir o problema de classes, 
  \lang{structs} e \lang{unions} aninhadas. De fato, nosso \textit{parser} de \CXX{} já reconheçe
  tal funcionalidade, só falta adaptarmos o gerador de código para tratar esse caso e testá-lo.
  
  Outra funcionalidade presente no OPWIG que não conseguimos fazer com o SWIG foi o registro automático
  de máquinas virtuais e de seus módulos disponíveis no \SMgr{}, simplificando o código do usuário
  para usar o sistema com suas máquinas virtuais e seus módulos gerados. Esse registro automático
  funciona da seguinte maneira: cada módulo gerado pelo OPWIG contém um bloco de código de \textit{bootstrap}
  (inicialização), que é executado automaticamente quando o programa é carregado, dado que ele tenha
  sido compilado juntamente com o código de \textit{wrapper} gerado. O \textit{bootstrap} então
  registra a máquina virtual da linguagem de \script{} relativa ao módulo em que ele está definido
  no \SMgr{}, caso ela ainda não tenha sido registrada, e registra o módulo de \script{} e seus sub-módulos
  nela.
  
  Internamente, o OPWIG contém:
  \begin{itemize}
    % TODO: Falar sobre o flexc++ e o bisonc++
    \item Um \textit{parser} de \CXX{}.
    \item Classes representando metadados de \CXX{}.
    \item Um gerador de código, que gera código de acordo com uma ``especificação''
      de uma linguagem de \script{}.
    \item A definição abstrata da especificação de uma linguagem de \script{}, que recebe
      os metadados para retornar o código que deverá ser escrito no arquivo gerado. Essa
      definição abstrata deve ser implementada para uma dada linguagem de \script{} para
      que o OPWIG seja capaz de gerar código para tal linguagem. Por padrão, nós criamos
      a implementação para Lua e Python.
  \end{itemize}
 

  \section{Módulos de CMake}
  
  TODO
