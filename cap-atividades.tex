\def\classname#1{\texttt{#1}}

\chapter{Atividades Realizadas}
\label{sec:atividades}

  O objetivo desse capítulo é relatar as diversas atividades realizadas no
  planejamento e desenvolvimento do Projeto Ouroboros. Como ele é anterior ao
  nosso trabalho de formatura, descrevemos também as atividades dos anos
  anteriores. Explicamos como de fato implementamos a solução apresentada no
  capítulo anterior, as dificuldades técnicas encontradas e todos os outros
  recursos que utilizamos para concretizar nossa ideia.
  
  \section{Origem do projeto}
  \label{sec:atividades:origem}
  
    %TODO "estes que vos escrevem"
    %TODO Essa seção precisa ser beeeeeem mais detalhada.
    A proposta desse projeto foi elaborada no início deste ano, para o nosso
    trabalho de formatura supervisionado. No entanto, o sistema em si já havia
    sido desenvolvido por nós desde o começo de 2011. Ele era parte da UGDK, uma
    \emph{engine} de desenvolvimento de jogos eletrônicos bidimensionais (ou
    simplesmente jogos 2D) programada pela equipe USPGameDev, da qual
    fazemos parte\footnotemark. Nós desenvolvemos a porção que corresponde ao
    % "ao sistema atual" significa o quê?
    sistema atual quando acreditamos que seria útil que quem estivesse usando a
    UGDK pudesse facilmente integrar seus jogos com \script{s}.

    \footnotetext{
      O USPGameDev é um grupo de pesquisa e desenvolvimento de jogos da
      Universidade de São Paulo. A UGDK é um de seus principais projetos, e seu
      nome é um acrônimo que pode significar tanto \emph{USP Game Development
      Kit} quanto \emph{USPGameDev Kit}. Ela é desenvolvida em \CXX{}. Ver
      \url{uspgamedev.org} (última visita em 25/07/2013).
    }

    Mais especificamente, queríamos que essa integração fosse possível em um
    outro projeto, também do USPGameDev: o jogo eletrônico chamado \emph{Horus
    Eye}\footnotemark. Trata-se de uma aplicação feita em \CXX{} que usava os
    recursos da UGDK para construir os alicerces do jogo. A equipe estava tendo
    muitas dificuldades em expandir o conteúdo dele desde o seu lançamento em
    outubro de 2010, pois não só apenas os membros mais antigos sabiam programar
    em \CXX{}, como também só eles sabiam \emph{o quê} precisava ser mudado para
    obter os resultados desejados. O então chamado ``sistema de \script{s} da
    UGDK'' foi a solução que propomos.

    \footnotetext{
      Ver \url{uspgamedev.org/horus-eye} (último acesso em 25/07/2013)
    }

    Ele fornecia ferramentas que buscavam simplificar o máximo possível a
    troca de dados do jogo com arquivos de \script{}. Bastava isolar as
    partes mais críticas para a elaboração de conteúdo novo do jogo de maneira
    que elas pudessem ser programadas majoritariamente através de \script{s}. E
    dessa maneira tornamos possível aprimorar o jogo usando linguagens bem mais
    simples que \CXX{} e sem a necessidade de conhecer todas as minúcias do seu
    código.

    %TODO colocar imagens do horus antes e depois do sistema de scripts

    %
    %Dessa maneira, surgiu a ideia inicial de programar um conjunto de
    %funcionalidades capaz de facilitar a comunicação entre uma linguagem compilada
    %(\CXX{}) e uma linguagem de \script{}. No entanto, não conseguimos chegar
    %imediatamente a um consenso sobre qual linguagem de \script{} usar
    %especificamente. As mais comunmente conhecidas na área de desenvolvimento de
    %jogos eletrônicos são Lua e Python. Então de um lado tínhamos as vastas
    %extensões e facilidades de Python, e do outro a simplicidade minimalista e
    %versátil de Lua. O melhor jeito de resolver o impasse foi usar ambas.
    %
    %Isso levou ao então chamado "sistema de \script{s} da UGDK": um sistema que
    %premite que o desenvolvedor-usuário carregue módulos do seu jogo a partir de
    %\script{s} sem que ele tenha que se preocupar em determinar e tratar a linguagem
    %de origem deles. Com a ajuda de uma ferramenta que descobrimos nessa época
    %chamada SWIG, consequimos completar uma versão inicial do sistema de \script{s},
    %que existe até hoje no código da UGDK\footnote{Há planos para a UGDK usar
    %diretamente o sistema do Projeto Ouroboros quando ele estiver pronto,
    %abrindo mão do atual sistema de \script{s} próprio dela}.
  
  %\classname{UmaClasse} 
  %
  %\begin{codebox}
  %    \Procname{$\proc{XTR-mul}(x, y)$}
  %    \zi $\id{temp} \gets x_1 * y_2 + x_2 * y_1$
  %    \zi \Return $\proc{XTRElem}(x_2 * y_2 - \id{temp}, x_1 * y_1 -
  %    \id{temp})$
  %\end{codebox}

  \section{Decisões de projeto}
  \label{sec:actividads:decisoes}
  % TODO: Falar sobre as ferramentas básicas escolhidas: linguagem de
  %       programação, sistema operacional de preferência, compilador, etc.
  
  \section{Uma interface comum para Lua e Python.}
  \label{sec:atividades:opa}
  Desenvolver uma interface comum entre as duas linguagens de \script{} foi uma das 
  primeiras coisas que fizemos, e hoje o trabalho realizado nesse quesito foi o que
  formou a \emph{Ouroboros Project API} (OPA). Desde o começo já desenvolvemos uma
  % TODO: a frase abaixa está redundante com "interface genérica"
  interface genérica capaz de usar uma ou outra linguagem de \script{} sem
  diferenças na interface para o usuário.
  
  % TODO: Aqui começa se referindo à (classe) VirtualOBj no femenino. Mais
  %       adiante, refere-se ao (objeto) VirtualObj no masculino. Precisamos
  %       bolar um jeito de deixar isso mais consistente e menos discordante.
  %       (discordância de gênero é um erro de português)
  A principal classe dessa interface comum é a \VObj{}. Essa classe 
  encapsula um objeto qualquer de uma máquina virtual, podendo representar um
  módulo de \script{} carregado, uma instância de uma classe, um valor na máquina
  virtual, entre outros. É praticamente a única classe que o usuário precisa 
  % TODO: Dar alguns exemplos, como um usuário querendo ler um número de um script, etc.
  usar. Ela implementa alguns métodos que possibilitam ao usuário realizar 
  operações comuns a qualquer linguagem de \script{} sobre o tal objeto (se for
  % TODO: Melhor falar sobre os casos de erro em outro lugar.
  possível, caso contrário ela irá dar erro), e também sobreescreve alguns operadores
  de \CXX{} para facilitar o uso de algumas operações, como por exemplo:
  % TODO: Código de exemplo para todos esses itens! XD
  \begin{itemize}
    \item Executar o objeto como uma função: simplificado pelo operador \lang{()}
      do \CXX{}, permitindo você usar o próprio \VObj{} como uma função;
    \item Acessar e alterar atributos do objeto: simplificado pelo operador
      \lang{[]} do \CXX{}, permitindo você usar o próprio \VObj{} como uma
      tabela de símbolos;
    \item Executar um método do objeto (instância de uma classe): simplificado pelo
      operador \lang{|} do \CXX{}. Chamadas de métodos em linguagens de \script{} normalmente
      passam a instância da classe (o próprio objeto) como o primeiro argumento da
      função, e o uso desse operador com o objeto simplifica essa operação. Exemplo: 
      \begin{verbatim}
        (vObj | "nome_do_método")(argumentos)
      \end{verbatim}
    \item Conversão de valores: como a maioria dos métodos (e operadores) do
      \VObj{} recebe e retorna outros \VObj{}s, a conversão de valores é o que forma a
      principal ponte entre objetos de \CXX{} e objetos da máquina virtual. Para tanto, o \VObj{}
      possui 2 métodos \textit{templates} que possibilitam a conversão de valores entre
      os dois ambientes.
  \end{itemize}

  \begin{framed}
    \textit{Templates} são uma funcionalidade de \CXX{} que permite
    criar funções e classes genéricas, recebendo 1 ou mais tipos\footnotemark{} em uma notação especial,
    que a função ou classe usa de forma genérica em seu corpo. Exemplo de chamada de uma
    função \textit{template}:
  \begin{verbatim}
    função_genérica<tipo1, tipo2, ...>(argumentos);\end{verbatim}
  \end{framed}
  
  \footnotetext{
    \textit{Templates} também podem receber valores aritméticos e \textit{strings},
    mas para o propósito do nosso trabalho, somente usamos com tipos.
    % TODO: Não exatamente. O mais correto seria dizer que não usamos eles na interface do
    %       VirtualObj, apenas.
  }   
  
  Mas agora como que o usuário cria \VObj{s}? De algum lugar tem que vir os primeiros \VObj{s}, relativos
  aos módulos de \script{} carregados. É ai que entra a segunda principal classe dessa interface comum
  entre linguagens, e praticamente a única outra classe que o usuário precisa usar além dos \VObj{s}:
  o \SMgr{}.
  
  O \SMgr{} gerencia as máquinas virtuais que estão disponíveis no sistema, permitindo ao usuário
  executar algumas operações simples porém importantes nelas como um conjunto:
  \begin{itemize}
    \item Inicialização e Finalização: o \SMgr{} tem métodos para inicializar e finalizar o conjunto
      de máquinas virtuais. A inicialização é necessária para poder usá-las, e a finalização 
      termina as máquinas, liberando quaisquer recursos do computador que elas estejam usando.
    \item Registro e busca de máquinas virtuais: o \SMgr{} inicialmente não sabe quais são as máquinas
      virtuais disponíveis. O usuário pode tanto registrá-las manualmente com um simples método, quanto
      delegar essa responsabilidade para o código gerado pelo OPWIG, como veremos mais adiante.
      Caso seja necessário, ele pode buscar uma máquina virtual registrada.
    \item Executar código: o \SMgr{} permite ao usuário executar um código qualquer, dado como uma
      cadeia de caracteres, na máquina virtual de sua escolha.
    \item Carregar módulos: possivelmente o método mais importante do \SMgr{}, este método recebe
      um caminho para um \script{} (sem a extensão de arquivo). Ele então determina se o \script{}
      existe, e de acordo com a extensão do arquivo, qual máquina virtual deve rodá-lo. A tal máquina
      virtual então carrega o \script{} e a função retorna um \VObj{} representando o módulo em
      sua linguagem de \script{}.
  \end{itemize}
  
  \section{Integração com SWIG}
  O \emph{Simplified Wrapper and Interface Generator} (SWIG\footnotemark{}) é uma ferramenta
  para exportar uma interface \C{}/\CXX{} para diversas linguagens de \script{} de alto nível.
  Um dos usos padrão dessa ferramenta (e a forma como usamos) é gerar o código de \textit{wrapper}
  necessário para criar módulos em linguagem nativa para uma determinada linguagem de \script{}.
  E é isso que possibilita tal linguagem ter acesso a uma interface implementada em \CXX{}.
  
  \footnotetext{Disponível em: \url{http://www.swig.org/} (data de acesso: 2 de setembro de 2013).}
  
  Usamos o SWIG pois enquanto nossa interface comum, o OPA - definido na seção anterior -, 
  possibilita que o \CXX{} use linguagens de \script{}, também precisávamos de algo para que linguagens 
  de \script{} tenham acesso a interfaces \CXX{}. Após pesquisar possíveis soluções encontramos
  o SWIG, uma ferramenta já um tanto quanto antiga e usada na indústria que fazia basicamente o
  que queríamos.
  
  Como o SWIG é uma ferramenta já pronta, e que é executada para gerar código que será compilado
  % TODO: Não diga que não há integração XD faz essa seção parecer sem sentido
  com o código do usuário, não há muita integração entre ele e o nosso sistema. A principal
  integração está no fato que o OPA usa uma interface padrão (para cada linguagem de \script{})
  gerada pelo SWIG para conseguir converter instâncias de tipos do usuário entre \CXX{} e as
  máquinas virtuais.
  
  % TODO: Exemplos!
  O SWIG usa arquivos separados, seguindo a interface deles, para determinar quais arquivos
  de \CXX{} ele irá ler, e como irá gerar o \textit{wrapper} para tal código. Nesses arquivos
  de interface do SWIG é também possível incluir código que será posto no código gerado, ou usado
  internamente no código gerado em algumas etapas, como por exemplo nas conversões de valores
  que existem nos \textit{wrappers}. O segundo grupo de integrações com o SWIG que fizemos está
  nesses arquivos.
  
  Fizemos algumas coisas com diversos objetivos nesses arquivos de interface, mas podemos
  classificá-las de dois jeitos:
  \begin{enumerate}
    \item Código usado para dizer para o OPA quais são os tipos de usuário exportados para
      as máquinas virtuais, e as estruturas de dados do SWIG que representam eles. O OPA
      por sua vez necessita disso para poder converter tais tipos entre a máquina virtual
      e o \CXX{}.
    \item Código usado para mudar ou adicionar alguma funcionalidade ao \textit{wrapper}
      gerado. Tais códigos essencialmente tentam resolver algum problema do SWIG, como
      a incapacidade de herdar tipos de \CXX{} nas linguagens de \script{}. Veremos mais
      sobre esses problemas na próxima seção.
  \end{enumerate}
  
  
  \section{Problemas com SWIG}
  Ao longo do tempo em que fomos usando o SWIG notamos alguns problemas com ele, que eram
  refletidos no nosso sistema, impondo certas restrições. Alguns desses problemas conseguimos
  apaziguar com código posto nos arquivos de interface do SWIG, como mencionado na seção
  anterior.
  
  \begin{itemize}
    \item A determinação de \textit{disown} depende da API do usuário e não é prático usar.
      \textit{Disown} é o ato de fazer com que algum método da interface \CXX{} retire a posse
      de uma instância de uma classe \CXX{} que ele recebe como argumento da máquina virtual. 
      Quando a máquina virtual cria algum objeto \CXX{}, ou seja, um objeto da linguagem de 
      \script{} que encapsula uma instância de alguma classe \CXX{} que foi exportada, ela
      retém a posse de tal objeto. Quando a ela for remover tal objeto de \script{}, seja 
      lá por qual razão, se ela deter a posse do objeto, ela também irá remover a instância 
      \CXX{} encapsulada. Isso pode causar problemas se alguma parte do código \CXX{} tem 
      algum ponteiro para tal instância, e tenta remover ou simplesmente usar ela em algum
      momento após a máquina virtual ter removido a instância. Portanto fizemos que métodos
      da interface \CXX{} que recebem instâncias de classes e cuidam da remoção delas 
      internamente tiram a posse de tal instância da máquina virtual.
      % TODO: Faltou falar mais sobre o verdadeiro problema: a impraticidade do designdo
      %       SWIG em reconhecer essas especificações. A questão da posse em si é
      %       inerente ao problema, e não tem como ser evitada.
    \item O SWIG não tem suporte a classes, \textit{structs} e \textit{unions} aninhadas, e 
      aparentemente não pretende ter tão cedo. Aninhar tais estruturas de \CXX{} é o ato
      de definir algumas delas dentro de outra.
    \item SWIG não tem suporte a herança de classes \CXX{} nos \script{s}. A nossa ``solução''
      para isso foi criar um sistema de \textit{proxies}\footnotemark: classes \CXX{} que derivam de uma
      classe base \textit{proxy} e da classe ``alvo'' \CXX{} que foi exportada para \script{}.
      Essas classes \textit{proxy} contém um \VObj{} com um objeto de script que deve ser uma
      instância da classe de \script{} que derive da classe \CXX{}. Elas também implementam 
      os métodos virtuais da classe base, usando o \VObj{} para repassar a chamada do método
      para o objeto virtual. Fora a definição da classe \textit{proxy} base, e das \textit{proxy}
      para cada classe \CXX{} passível de ser herdada, para esse sistema funcionar foi também
      necessário uma grande parte de código adicionado nos arquivos de interface do SWIG.
      
      \footnotetext{Uma alternativa para simplificar esse processo está no nosso blog: 
        \url{http://projeto-ouroboros.blogspot.com.br/2013/07/gerador-de-proxies.html}}
      
    \item O SWIG não exporta em seus \textit{wrappers} variáveis e métodos de classes com 
      modificador de acesso \textit{protected} (acessíveis somente pela classe em si e por 
      classes derivadas). Isso decorre do fato que ele não tem suporte a herança, como mencionado
      anteriormente, mas ainda assim é um problema ao nosso ver.
    \item Problemas com \textit{wrappers} de Lua:
      %TODO: WIL! Acho que essa parte vc deve ver direito...
      \begin{itemize}
        \item Uma das informações necessárias (metatabelas das classes) só pode ser obtida
          fazendo suposições sobre a implementação interna dos \textit{wrappers} de Lua do SWIG.
        \item Duas funções internas dos \textit{wrappers} de Lua do SWIG precisam ter uma linha
          de código alterada para que \textit{proxies} funcionem.
      \end{itemize}
  \end{itemize}
  
  \section{Nosso próprio gerador de \emph{wrappers}}
  Boa parte do que explicamos nas seções anteriores neste capítulo foi o trabalho que realizamos
  antes do trabalho de formatura. E o principal ponto do trabalho é exatamente o de substituir 
  o SWIG por uma ferramenta própria que criamos, a fim de simplificar o uso e corrigir os
  erros listados na seção anterior. Mantemos o OPA, fazendo algumas alterações para resolver
  erros, melhorar o sistema ou substituir as partes relativas ao SWIG para a nossa nova ferramenta.
  
  Foi então que surgiu o nosso próprio gerador de \textit{wrappers}, o \emph{Ouroboros Project 
  Wrapper and Interface Generator} (OPWIG).
  
  Enquanto o OPWIG ainda não é capaz de substituir completamente o SWIG, ele já realiza algumas
  tarefas básicas importantes, como exportar funções, variáveis e classes simples. E continuamos
  o seu desenvolvimento num passo constante razoável. Infelizmente não podemos ainda falar que
  já conseguimos resolver os problemas do SWIG pois como nossa ferramenta ainda está no começo
  do desenvolvimento, ainda não chegamos no ponto de ocorrer tais erros. 
  
  Mas pelo menos já conseguimos notar que será relativamente fácil corrigir o problema de classes, 
  \textit{structs} e \textit{unions} aninhadas. De fato, nosso \textit{parser} de \CXX{} já reconheçe
  tal funcionalidade, só falta adaptarmos o gerador de código para tratar esse caso e testá-lo.
  
  Outra funcionalidade presente no OPWIG que não conseguimos fazer com o SWIG foi o registro automático
  de máquinas virtuais e de seus módulos disponíveis no \SMgr{}, simplificando o código do usuário
  para usar o sistema com suas máquinas virtuais e seus módulos gerados. Esse registro automático
  funciona da seguinte maneira: cada módulo gerado pelo OPWIG contém um bloco de código de \textit{bootstrap}
  (inicialização), que é executado automaticamente quando o programa é carregado, dado que ele tenha
  sido compilado juntamente com o código de \textit{wrapper} gerado. O \textit{bootstrap} então
  registra a máquina virtual da linguagem de \script{} relativa ao módulo em que ele está definido
  no \SMgr{}, caso ela ainda não tenha sido registrada, e registra o módulo de \script{} e seus sub-módulos
  nela.
  
  Internamente, o OPWIG contém:
  \begin{itemize}
    % TODO: Falar sobre o flexc++ e o bisonc++
    \item Um \textit{parser} de \CXX{}.
    \item Classes representando metadados de \CXX{}.
    \item Um gerador de código, que gera código de acordo com uma ``especificação''
      de uma linguagem de \script{}.
    \item A definição abstrata da especificação de uma linguagem de \script{}, que recebe
      os metadados para retornar o código que deverá ser escrito no arquivo gerado. Essa
      definição abstrata deve ser implementada para uma dada linguagem de \script{} para
      que o OPWIG seja capaz de gerar código para tal linguagem. Por padrão, nós criamos
      a implementação para Lua e Python.
  \end{itemize}
 
  
  \section{Módulos de CMake}
  
  TODO
