\chapter{Atividades Realizadas}
\label{sec:atividades}

  %TODO: tirar o "até o momento" na versão final
  O objetivo desse capítulo é relatar as diversas atividades realizadas (até o
  momento) no planejamento e desenvolvimento do Projeto Ouroboros. Como ele é
  anterior ao nosso trabalho de formatura, descrevemos também as atividades dos
  anos anteriores. Explicamos como de fato implementamos a solução apresentada no
  capítulo anterior, as dificuldades técnicas encontradas e todos os outros
  recursos que utilizamos para concretizar nossa ideia.
  
  \section{Origem do projeto}
  \label{sec:atividades:origem}
  
    %TODO "estes que vos escrevem"
    %TODO Essa seção precisa ser beeeeeem mais detalhada.
    A proposta desse projeto foi elaborada no início deste ano, para o nosso
    trabalho de formatura supervisionado. No entanto, o sistema em si já havia
    sido desenvolvido por nós desde o começo de 2011. Ele era parte da UGDK, uma
    \emph{engine}\footnote{Mais informações:
    \url{http://en.wikipedia.org/wiki/Game\_engine} (último acesso: 15/09/2013)}
    de desenvolvimento de jogos eletrônicos bidimensionais (ou
    simplesmente ``jogos 2D'') programada pela equipe USPGameDev, da qual
    fazemos parte. Nós desenvolvemos a porção que corresponde ao
    % "ao sistema atual" significa o quê?
    sistema atual quando acreditamos que seria útil que quem estivesse usando a
    UGDK pudesse facilmente integrar seus jogos com \script{s}.

    Mais especificamente, queríamos que essa integração fosse possível em um
    outro projeto, também do USPGameDev: o jogo eletrônico chamado \emph{Horus
    Eye}\footnotemark. Trata-se de uma aplicação feita em \CXX{} que usava os
    recursos da UGDK para construir os alicerces do jogo. A equipe estava tendo
    muitas dificuldades em expandir o conteúdo dele desde o seu lançamento em
    outubro de 2010, pois não só apenas os membros mais antigos sabiam programar
    em \CXX{}, como também só eles sabiam \emph{o quê} precisava ser mudado para
    obter os resultados desejados. O então chamado ``sistema de \script{s} da
    UGDK'' foi a solução que propomos.

    \footnotetext{
      Ver \url{uspgamedev.org/horus-eye} (último acesso: 25/07/2013)
    }

    Ele fornecia ferramentas que buscavam simplificar o máximo possível a
    troca de dados do jogo com arquivos de \script{}. Bastava isolar as
    partes mais críticas para a elaboração de conteúdo novo do jogo de maneira
    que elas pudessem ser programadas majoritariamente através de \script{s}. E
    dessa maneira tornamos possível aprimorar o jogo usando linguagens bem mais
    simples que \CXX{} e sem a necessidade de conhecer todas as minúcias do seu
    código.

    %TODO colocar imagens do horus antes e depois do sistema de scripts

  %\classname{UmaClasse} 
  %
  %\begin{codebox}
  %    \Procname{$\proc{XTR-mul}(x, y)$}
  %    \zi $\id{temp} \gets x_1 * y_2 + x_2 * y_1$
  %    \zi \Return $\proc{XTRElem}(x_2 * y_2 - \id{temp}, x_1 * y_1 -
  %    \id{temp})$
  %\end{codebox}

  \section{Decisões de projeto}
  \label{sec:actividads:decisoes}
  % TODO: checar toda essa seção (e sub-seções) por erros, e provavelmente
  %       tem que arrumar um monte de coisa pra indicar o que é ou onde 
  %       encontrar essas ferramentas (como CMake, Git, etc).

  \subsection{Decisões anteriores ao Trabalho de Formatura}
  Quando começamos a desenvolver o nosso ``sistema de \script{s}'',
  como ele era integrado à UGDK e fazia parte do USPGameDev, muitas das
  nossas decisões do projeto refletiam os padrões de projeto que seguíamos
  no grupo. Escolhemos \CXX{} como a linguagem de programação a ser usada
  para desenvolver o sistema pois essa era a linguagem que a UGDK e os nossos
  jogos usavam, e além disso é comum linguagens de \script{} terem uma
  implementação de sua máquina virtual em \C{}, ou até \CXX{}. Como \CXX{}
  contém em si todas as funcionalidades de \C{}, não temos perda técnica nenhuma
  em usar o primeiro ao invés do segundo.
  
  Também decidimos inicialmente que o sistema seria generalizado para poder
  funcionar com possivelmente qualquer linguagem de \script{}, sendo que
  inicialmente iríamos incluir compatibilidade com Lua (a qual o Wilson conhece
  bem) e Python (usada regularmente pelo Fernando). Para prover a geração de 
  \textit{wrappers}, escolhemos o SWIG, que foi a melhor opção para o que 
  necessitávamos segundo nossa pesquisa (o que essa ferramenta faz e como
  usamos ela será melhor explicado mais adiante, na seção \ref{sec:actividads:integracaoswig}).
  
  Como os projetos do USPGameDev usavam CMake para simplificar sua compilação
  em diversas plataformas e compiladores, nós também usamos essa ferramenta.
  Usualmente progamávamos em Linux (Debian ou Ubuntu) usando \lang{g++} como compilador,
  ou em Windows com o Visual Studio 2010. Para controle de versão do código fonte
  usamos o mesmo repositório da UGDK, que usava Git, hospedado no GitHub.

  %TODO: HOLY CRAP PRECISAMOS REFERENCIAR TODAS ESSAS FERRAMENTAS!
  
  \subsection{Mudanças no Projeto para o Trabalho de Formatura}
  Quando começamos o trabalho de formatura, fizemos algumas mudanças nas nossas
  decisões de projeto originais. Primeiramente, separamos o sistema para ser um
  projeto separado, totalmente independente de qualquer outro projeto do
  USPGameDev, e o nomeamos Projeto Ouroboros. Partindo do código de fonte
  original, criamos outro repositório Git específico para o Ouroboros, ainda
  hospedado no GitHub.
  
  Também decidimos atualizar a linguagem de programação usada para \CXX{11},
  uma versão bem mais recente do \CXX{} clássico, com diversas melhorias e
  novas funcionalidades. Isso introduziu um problema no projeto: qual compilador
  poderíamos usar. Como o \CXX{11} ainda é razoavelmente recente, nem todos
  compiladores reconhecem todas suas novas funcionalidades. Mais notavelmente,
  não conseguimos mais compilar no Windows com o Visual Studio 2010, e nem com
  sua versão mais recente, Visual Studio 2012. No Linux, tivemos que usar uma
  versão mais recente do \lang{gcc}, a 4.7. Apesar de existirem versões ainda mais 
  recentes, essa era a mínima necessária. Como ela não é fornecido por padrão
  nos pacotes do Ubuntu LTS\footnotemark{} atual, tivemos que adaptar nossos
  ambientes de desenvolvimento para conseguir usar um \lang{g++} mais recente.
  %melhorar essa parte... ta meio estranho essa coisa do g++

  \footnotetext{
    \emph{Long Term Service}.
  }

  Como parte do trabalho de formatura, tiramos o SWIG do projeto para substituí-lo
  pelo nosso gerador de \textit{wrappers}, o OPWIG (mais sobre ele na seção 
  \ref{sec:actividads:opwig}). Também passamos a criar e usar bem mais testes
  unitários para testar o nosso código, além de registrar nosso repositório Git
  no Travis\footnotemark, que automaticamente tenta compilar nosso projeto e
  rodar todos os testes.
  
  \footnotetext{
    O Travis (\url{https://travis-ci.org/Rewasvat/ouroboros/}, último acesso:
    15/09/2013) é um servidor de integração contínua: ele automaticamente faz
    \emph{download} do seu repositório quando há alguma mudança nele, e executa
    uma sequência pré-determinada de comandos para verificar se o código compila
    e passa nos testes.
   }
  
  Nossa metodologia de trabalho também foi alterada. Passamos a desenvolver o
  sistema separadamente do USPGameDev, manter listas de tarefas pendentes e a
  ter objetivos fixados periodicamente para serem completados o quanto antes.
  
  \section{Uma interface comum para Lua e Python.}
  \label{sec:atividades:opa}
  Desenvolver uma interface comum entre as duas linguagens de \script{} foi uma das 
  primeiras coisas que fizemos, e hoje o trabalho realizado nesse quesito foi o que
  formou a \emph{Ouroboros Project API} (OPA). Desde o começo vimos desenvolvemos uma
  interface generalizada capaz de usar uma ou outra linguagem de \script{} sem
  diferenças na interface para o usuário. A seguir explicamos as principais
  classes da OPA.
  
  % TODO: Aqui começa se referindo à (classe) VirtualOBj no femenino. Mais
  %       adiante, refere-se ao (objeto) VirtualObj no masculino. Precisamos
  %       bolar um jeito de deixar isso mais consistente e menos discordante.
  %       (discordância de gênero é um erro de português)
  \subsection{\VObj{}}
  \label{sec:atividades:opa:vobj}
  Essa classe encapsula um objeto qualquer de uma máquina virtual, podendo
  representar um módulo de \script{} carregado, uma instância de uma classe, um
  valor na máquina virtual, entre outros. É praticamente a única classe que o
  usuário precisa usar. Ela implementa alguns métodos que possibilitam ao
  usuário realizar sobre o tal objeto operações comuns a qualquer linguagem de
  \script{}. Também sobreescreve alguns operadores de \CXX{} para facilitar o
  uso de algumas dessas operações, como por exemplo:
  \begin{itemize}
    \item Executar o objeto como uma função: simplificado pelo operador \lang{()}
      do \CXX{}, permitindo ao usuário usar o próprio \VObj{} como uma função. Exemplo:
      \begin{lstlisting}
        VirtualObj vObj, vReturnObj, vObjArg1, ... vObjArgN; 
        VirtualObj::List vObjList; // <=> std::list<VirtualObj> vObjList
                                   // lista de VirtualObj.
                                   
        vReturnObj = vObj();
        vReturnObj = vObj( vObjArg1, vObjArg2, ... , vObjArgN );
        vReturnObj = vObj( vObjList );
      \end{lstlisting}
    \item Acessar e alterar atributos do objeto: simplificado pelo operador
      \lang{[]} do \CXX{}, permitindo ao usuário usar o próprio \VObj{} como uma
      tabela de símbolos. Exemplo:
      \begin{lstlisting}
        VirtualObj vObj, vAttrObj, vObj_AttrName;
        vAttrObj = vObj["nome_do_atributo"];
        vAttrObj = vObj[ vObj_AttrName ];
      \end{lstlisting}
    \item Executar um método do objeto (instância de uma classe): simplificado pelo
      operador \lang{|} do \CXX{}. Chamadas de métodos em linguagens de \script{} normalmente
      passam a instância da classe (o próprio objeto) como o primeiro argumento da
      função, e o uso desse operador com o objeto simplifica essa operação. Exemplo: 
      \begin{lstlisting}
        // Recebe argumentos como nas chamadas de funcao
        (vObj | "nome_do_metodo")( ... );
      \end{lstlisting}
    \item Conversão de valores: como a maioria dos métodos (e operadores) do
      \VObj{} recebe e retorna outros \VObj{}s, a conversão de valores é o que forma a
      principal ponte entre objetos de \CXX{} e objetos da máquina virtual. Para tanto, o \VObj{}
      possui 2 métodos \textit{templates} que possibilitam a conversão de valores entre
      os dois ambientes. Exemplo:
      \begin{lstlisting}
        T* valor = vObj.value<T*>();
        vObj.set_value<T*>(valor);
        
        VirtualObj vNumObj; //suponha um VirtualObj contendo um numero
        double num = vNumObj.value<double>(); // pegar o valor
        vNumObj.set_value<double>(num);       // atribuir o valor
      \end{lstlisting}
  \end{itemize}

  \begin{framed}
    \textit{Templates} são uma funcionalidade de \CXX{} que permite
    criar funções e classes genéricas, recebendo 1 ou mais tipos\footnotemark{} em uma notação especial,
    que a função ou classe usa de forma genérica em seu corpo. Exemplo de chamada de uma
    função \textit{template}:
  \begin{verbatim}
    função_genérica<tipo1, tipo2, ...>(argumentos);\end{verbatim}
  \end{framed}
  
  \footnotetext{
    \textit{Templates} também podem receber valores aritméticos e \str{s},
    mas na interface do \VObj{}, e na maioria do nosso trabalho, somente usamos com tipos.
  }
  
  Na prática, o \VObj{} é uma classe que encapsula um \VData{}. Todas essas operações do
  \VObj{} são repassadas para seu \VData{} usando um padrão de projeto chamado
  \textbf{ponteiro para implementação}\footnotemark{}. Essa classe, que representa um objeto numa máquina
  virtual específica, não deve ser usada diretamente pelo usuário. Para isso existe o
  \VObj{}. Mais sobre o \VData{} pode ser visto na subseção \ref{sec:atividades:opa:vdata}
  
  \footnotetext{
    \url{
      http://en.wikibooks.org/wiki/C++\_Programming/Idioms\#Pointer\_To\_Implementation\_.28pImpl.29
    } (último acesso: 15/09/2013)
  }
  
  \subsection{\SMgr{}}
  \label{sec:atividades:opa:smgr}
  %TODO: explicar melhor o problema da origem dos vobjs
  Mas como que o usuário cria um \VObj{}? De algum lugar tem que vir os primeiros \VObj{s}, relativos
  aos módulos de \script{} carregados. É ai que entra a segunda principal classe dessa interface comum
  entre linguagens, e praticamente a única outra classe que o usuário precisa usar além dos \VObj{s}:
  o \SMgr{}.
  
  O \SMgr{} é uma classe que segue o padrão de projeto
  \textbf{\textit{singleton}}\footnotemark{} e gerencia as máquinas virtuais que
  estão disponíveis no sistema, permitindo ao usuário executar algumas operações
  simples porém importantes nelas como um conjunto:

  \footnotetext{
    \textit{Singleton} é um padrão de projeto que permite ter apenas uma instância de uma classe
    num dado momento. Mais informações:
    \url{http://en.wikipedia.org/wiki/Singleton\_pattern} (último acesso: 15/09/2013)
    }
  
  \begin{itemize}
    \item Inicialização e Finalização: o \SMgr{} tem métodos para inicializar e finalizar o conjunto
      de máquinas virtuais. A inicialização é necessária para poder usá-las e também serve para
      especificar o diretório na qual \script{s} serão carregados pelo \SMgr{}. A finalização 
      encerra a atividade das máquinas, liberando quaisquer recursos do computador que elas
      estejam usando. Exemplo:
      \begin{lstlisting}
        //SCRIPT_MANAGER() eh uma macro que retorna um ponteiro para a instancia do ScriptManager.
        bool ok = SCRIPT_MANAGER()->Initialize("./caminho/para/os/scripts/");
        
        SCRIPT_MANAGER()->Finalize();
      \end{lstlisting}
      Se o valor booleano que o \lang{Initialize} retorna for verdadeiro, o \SMgr{} foi inicializado
      sem problemas. Caso contrário ocorreu algum problema na inicialização dele.
    \item Registro e busca de máquinas virtuais: o \SMgr{} inicialmente não sabe quais são as máquinas
      virtuais disponíveis. O usuário pode tanto registrá-las manualmente com um simples método, quanto
      delegar essa responsabilidade para o código gerado pelo OPWIG, como veremos mais adiante.
      Caso seja necessário, ele pode buscar uma máquina virtual registrada. As máquinas virtuais
      são representadas no nosso sistema pela classe \VMac{}, que é uma classe abstrata,
      devendo ser implementada para cada máquina virtual. Exemplo:
      \begin{lstlisting}
        //Registrando uma maquina virtual.
        VirtualMachine* vm = new python::PythonMachine();
        SCRIPT_MANAGER()->Register(vm);
        
        //Buscando uma maquina virtual.
        VirtualMachine* pyvm = SCRIPT_MANAGER()->GetMachine("Python");
        //pyvm corresponde ao mesmo vm declarado antes.
      \end{lstlisting}
    \item Executar código: o \SMgr{} permite ao usuário executar um código qualquer, dado como uma
      cadeia de caracteres, na máquina virtual de sua escolha. Exemplo:
      \begin{lstlisting}
        SCRIPT_MANAGER()->ExecuteCode("Lua", "print(42)");
      \end{lstlisting}
    \item Carregar módulos: possivelmente o método mais importante do \SMgr{}, este método recebe
      um caminho para um \script{} (sem a extensão de arquivo). Ele então determina se o \script{}
      existe, e de acordo com a extensão do arquivo, qual máquina virtual deve rodá-lo. A tal máquina
      virtual então carrega o \script{} e a função retorna um \VObj{} representando o módulo em
      sua linguagem de \script{}. Exemplo:
      \begin{lstlisting}
        VirtualObj modulo = SCRIPT_MANAGER()->LoadModule("modulo");
        VirtualObj modul2 = SCRIPT_MANAGER()->LoadModule("pacote.subpacote.modulo");
      \end{lstlisting}
  \end{itemize}
  
  \subsection{\VMac{}}
  \label{sec:atividades:opa:vmac}
  A \VMac{} é uma das duas classes abstratas do sistema que devem ser implementadas para
  cada linguagem que se deseja ser compatível com a OPA. A \VMac{} representa a máquina
  virtual da linguagem em si, sendo usada internamente pelo \SMgr{}. Raramente ela será
  usada diretamente pelo usuário. Alguns métodos importantes de sua interface são:
  
  \begin{itemize}
    \item Inicialização e Finalização da máquina virtual. São chamados pelo \SMgr{} internamente.
    \item Método para retornar a cadeia de caracteres correspondente à extensão de um 
      arquivo de \script{} dessa linguagem.
    \item Carregar módulos, chamado pelo \SMgr{} internamente.
    \item Executar código arbitrário, também chamado pelo \SMgr{}.
    \item Retornar um novo \VData{} (ver próxima seção) vazio correspondente a essa linguagem
      (uma instância vazia da classe que implementa a abstração \VData{} para esta linguagem).
  \end{itemize}
  
  \subsection{\VData{}}
  \label{sec:atividades:opa:vdata}
  \VData{} é a segunda classe abstrata do sistema que deve ser implementada para uma linguagem
  de \script{} poder ser usada pelo OPA. Ela representa um objeto contido na máquina virtual
  de uma linguagem específica.
  
  Essa classe é uma interface para métodos que devem implementar todas aquelas operações do 
  \VObj{} (descritas anteriormente), de forma que o \VObj{} chama essas funções na implementação
  de seus métodos e operadores. Assim, um \VObj{} pode ter um \VData{} de uma linguagem 
  ou de outra sem precisar saber qual, graças ao polimorfismo através de herança.
  
  Fora métodos para as operações descritas na subseção \ref{sec:atividades:opa:vobj}, um ponto
  importante da interface do \VData{} é um método para retornar a instância (contida no \SMgr{}) 
  da implementação do \VMac{} que representa a máquina virtual responsável pelo
  \VData{} em questão.
  
  
  \section{Integração com SWIG}
  \label{sec:actividads:integracaoswig}
  O \emph{Simplified Wrapper and Interface Generator} (SWIG\footnotemark{}) é uma ferramenta
  para exportar uma interface \C{}/\CXX{} para diversas linguagens de \script{} de alto nível.
  Um dos usos padrão dessa ferramenta (e a forma como usamos) é gerar o código de \textit{wrapper}
  necessário para criar módulos em linguagem nativa para uma determinada linguagem de \script{}.
  E é isso que possibilita tal linguagem ter acesso a uma interface implementada em \CXX{}.
  
  \footnotetext{Disponível em: \url{http://www.swig.org/} (último acesso:0 2/092013)}
  
  Usamos o SWIG pois enquanto nossa interface comum, o OPA - definido na seção anterior -, 
  possibilita que o \CXX{} use linguagens de \script{}, também precisávamos de algo para que linguagens 
  de \script{} tenham acesso a interfaces \CXX{}. Após pesquisar possíveis soluções encontramos
  o SWIG, uma ferramenta já um tanto quanto antiga e usada na indústria que fazia basicamente o
  que queríamos.
  
  Como o SWIG é uma ferramenta já pronta, e que é executada para gerar código que será compilado
  com o código do usuário, a integração entre ele e o nosso sistema é bem simples. A principal
  integração está no fato que o OPA usa uma interface padrão (para cada linguagem de \script{})
  gerada pelo SWIG para conseguir converter instâncias de tipos do usuário entre \CXX{} e as
  máquinas virtuais.
  
  % TODO: Exemplos (de como usar o swig)!
  O SWIG usa arquivos separados, seguindo a interface deles, para determinar quais arquivos
  de \CXX{} ele irá processar, e como irá gerar o \textit{wrapper} para tal código. Nesses arquivos
  de interface do SWIG é também possível incluir código que será posto no código gerado, ou usado
  internamente no código gerado em algumas etapas, como por exemplo nas conversões de valores
  que existem nos \textit{wrappers}. O segundo tipo de integrações com o SWIG que fizemos está
  nesses arquivos.
  
  Fizemos algumas coisas com diversos objetivos nesses arquivos de interface, mas podemos
  classificá-las de dois jeitos:
  \begin{enumerate}
    \item Código usado para dizer para o OPA quais são os tipos de usuário exportados para
      as máquinas virtuais, e as estruturas de dados do SWIG que representam eles. O OPA
      por sua vez necessita disso para poder converter tais tipos entre a máquina virtual
      e o \CXX{}.
    \item Código usado para mudar ou adicionar alguma funcionalidade ao \textit{wrapper}
      gerado. Tais códigos essencialmente tentam resolver algum problema do SWIG, como
      a incapacidade de herdar tipos de \CXX{} nas linguagens de \script{}. Veremos mais
      sobre esses problemas na próxima seção.
  \end{enumerate}
  
  
  \section{Problemas com SWIG}
  Ao longo do tempo em que fomos usando o SWIG notamos alguns problemas com ele, que eram
  refletidos no nosso sistema, impondo certas restrições. Alguns desses problemas conseguimos
  apaziguar com código posto nos arquivos de interface do SWIG, como mencionado na seção
  anterior. Os problemas eram:
  
  \begin{itemize}
    \item A determinação de \textit{disown} depende da API do usuário e não é prático usar.
      \textit{Disown} é o ato de fazer com que algum método da interface \CXX{} retire a posse
      de uma instância de uma classe \CXX{} que ele recebe como argumento da máquina virtual. 
      Quando a máquina virtual cria algum objeto \CXX{}, ou seja, um objeto da linguagem de 
      \script{} que encapsula uma instância de alguma classe \CXX{} que foi exportada, ela
      retém a posse de tal objeto. Quando ela for remover tal objeto de \script{}, seja 
      lá por qual razão, se ela deter a posse do objeto, ela também irá remover a instância 
      \CXX{} encapsulada. Isso pode causar problemas se alguma parte do código \CXX{} tem 
      algum ponteiro para tal instância, e tenta remover ou simplesmente usar ela em algum
      momento após a máquina virtual tê-la removido da memória. Portanto fizemos que métodos
      da interface \CXX{} que recebem instâncias de classes e cuidam da remoção delas 
      internamente tiram a posse de tal instância da máquina virtual.
      % TODO: Faltou falar mais sobre o verdadeiro problema: a impraticidade do design do
      %       SWIG em reconhecer essas especificações. A questão da posse em si é
      %       inerente ao problema, e não tem como ser evitada.
    \item O SWIG não aceita o aninhamento de classes, \textit{structs} e \textit{unions}, e 
      %TODO: citation neeeded!
      aparentemente não pretende aecitar tão cedo. Aninhar tais estruturas de \CXX{} é o ato
      de definir algumas delas dentro de outra.
    \item SWIG não tem suporte a herança de classes \CXX{} nos \script{s}. A nossa ``solução''
      para isso foi criar um sistema de \textit{proxies}\footnotemark: classes intermediárias em
      \CXX{} que derivam de uma classe base \lang{BaseProxy} e da classe ``alvo'' \CXX{} que foi
      exportada para \script{}. Essas classes \textit{proxy} contêm um \VObj{} com um objeto de
      script que deve ser uma instância da classe de \script{} que derive da classe \CXX{}. Elas
      também implementam os métodos virtuais da classe base, usando o \VObj{} para repassar a
      chamada do método para o objeto virtual. Fora a definição da classe \lang{BaseProxy}, e
      das classes \textit{proxy} para cada classe \CXX{} passível de ser herdada, para esse
      sistema funcionar foi também necessário uma grande parte de código adicionado nos arquivos de
      interface do SWIG.
      
      \footnotetext{
        Uma alternativa para simplificar esse processo está no nosso blog: 
        \url{http://projeto-ouroboros.blogspot.com.br/2013/07/gerador-de-proxies.html}
        (último acesso: 15/09/2013)
      }
      
    \item O SWIG não exporta em seus \textit{wrappers} variáveis e métodos de classes com 
      modificador de acesso \textit{protected} (acessíveis somente pela classe em si e por 
      classes derivadas). Isso decorre do fato que ele não tem suporte a herança, como mencionado
      anteriormente, mas ainda assim é um problema ao nosso ver.
    \item Problemas com \textit{wrappers} de Lua:
      %TODO: WIL! Acho que essa parte vc deve ver direito...
      \begin{itemize}
        \item Uma das informações necessárias (metatabelas das classes) só pode ser obtida
          fazendo suposições sobre a implementação interna dos \textit{wrappers} de Lua do SWIG.
        \item Duas funções internas dos \textit{wrappers} de Lua do SWIG precisam ter uma linha
          de código alterada para que \textit{proxies} funcionem.
      \end{itemize}
  \end{itemize}
  
  \section{Nosso próprio gerador de \emph{wrappers}}
  \label{sec:actividads:opwig}
  Boa parte do que explicamos nas seções anteriores neste capítulo foi o trabalho que realizamos
  antes do trabalho de formatura. E o principal ponto do trabalho é exatamente o de substituir 
  o SWIG por uma ferramenta própria que criamos, a fim de simplificar o uso e corrigir os
  erros listados na seção anterior. Mantemos o OPA, fazendo algumas alterações para resolver
  erros, melhorar o sistema ou substituir as partes relativas ao SWIG para a nossa nova ferramenta.
  
  Foi então que surgiu o nosso próprio gerador de \textit{wrappers}, o \emph{Ouroboros Project 
  Wrapper and Interface Generator} (OPWIG).
  
  Enquanto o OPWIG ainda não é capaz de substituir completamente o SWIG, ele já realiza algumas
  tarefas básicas importantes, como exportar funções, variáveis e classes simples. E continuamos
  o seu desenvolvimento num passo constante razoável. Infelizmente não podemos ainda falar que
  já conseguimos resolver os problemas do SWIG pois como nossa ferramenta ainda está no começo
  do desenvolvimento, ainda não chegamos no ponto de ocorrer tais erros. 
  
  Mas pelo menos já conseguimos notar que será relativamente fácil corrigir o problema de classes, 
  \lang{structs} e \lang{unions} aninhadas. De fato, nosso \textit{parser} de \CXX{} já reconhece
  tal funcionalidade, só falta adaptarmos o gerador de código para tratar esse caso e testá-lo.
  
  Outra funcionalidade presente no OPWIG que não conseguimos fazer com o SWIG foi o registro automático
  de máquinas virtuais no \SMgr{}, simplificando o código do usuário para usar o sistema com suas máquinas
  virtuais e seus módulos gerados. Esse registro automático funciona da seguinte maneira: cada módulo gerado
  pelo OPWIG contém um bloco de código de \textit{bootstrap} (inicialização), que é executado automaticamente
  quando o programa é carregado, dado que ele tenha sido compilado juntamente com o código de \textit{wrapper}
  gerado. O \textit{bootstrap} então registra a máquina virtual da linguagem de \script{} relativa ao módulo
  em que ele está definido no \SMgr{}, caso ela ainda não tenha sido registrada, e registra o módulo de
  \script{} e seus sub-módulos nela.
  
  Internamente, o OPWIG contém:
    \cite{flex:00}
  \begin{itemize}
    % TODO: Falar sobre o flexc++ e o bisonc++
    \item Um \textit{parser} de \CXX{}.
    \item Classes representando metadados de \CXX{}.
    \item Um gerador de código, que gera código de acordo com uma ``especificação''
      de uma linguagem de \script{}.
    \item A definição abstrata da especificação de uma linguagem de \script{}, que recebe
      os metadados para retornar o código que deverá ser escrito no arquivo gerado. Essa
      definição abstrata deve ser implementada para uma dada linguagem de \script{} para
      que o OPWIG seja capaz de gerar código para tal linguagem. Novamente, por padrão, nós
      criamos a implementação para Lua e Python.
  \end{itemize}
 

  \section{Módulos de CMake}
  
    Isso será escrito na versão final da monografia.
