\chapter{Resultados}
\label{sec:resultados}

Neste capítulo iremos apresentar os resultados obtidos ao longo do
desenvolvimento do Projeto Ouroboros. Parte desses resultados foram
obtidos antes do trabalho de formatura, mas ainda assim foram aprimorados
durante o processo de desenvolvimento do trabalho.

Juntos, os resultados formam o que chamamos de sistema do Projeto Ouroboros.
Separadamente, cada resultado corresponde a uma forma generalizada de implementar
as interações entre linguagens especificadas na seção \ref{cap:estrutura:geral}.
A incorporação foi implementada pelo OPA (seção \ref{sec:resultados:libouroboros}),
e a exportação pelo OPWIG (seção \ref{sec:resultados:opwig})


\section{Biblioteca \textbf{libouroboros}}
\label{sec:resultados:libouroboros}
A libouroboros é uma biblioteca \CXX{} que como o nome já indica, contém
o sistema ouroboros.

Ela contém o OPA, com praticamente todas as funcionalidades desejadas 
implementadas e funcionando normalmente: um sistema para gerenciar as máquinas
virtuais desejadas, para carregar \script{s} independente de sua
linguagem, e uma interface simples, genérica e robusta para
que o usuário de \CXX{} mexa com a máquina virtual e seus \script{s}.

E ela também contém o código do OPWIG (mais sobre ele na próxima seção
\ref{sec:resultados:opwig}).

É provável que ainda alteremos algumas coisas no sistema, arrumando alguma
coisa ou implementando novas funcionalidades.

A \lang{libouroboros} também é facilmente compilada em várias plataformas usando
o CMake para gerar arquivos relativos à compilação, como \textit{Makefile}s
no Linux. As implementações que fizemos das interfaces abstratas da OPA e do 
OPWIG para as linguagens de \script{} \lang{Python} e \lang{Lua} também estão totalmente funcionais,
sendo distríbuidas juntamente com a \lang{libouroboros} e sendo compiladas em
bibliotecas diferentes: \lang{libouroboros-python} e \lang{libouroboros-lua},
para \lang{Python} e \lang{Lua}, respectivamente. Assim é fácil incorporá-las em um
mesmo programa, basta ligar o programa com a \lang{libouroboros} e com elas. 
Caso o usuário não queira usar uma das linguagens, é só não ligar com 
as bibliotecas correspondentes. Caso ele queira usar outra linguagem, é
só ele obter a implementação da \lang{libouroboros} específica dela e ligá-la junto.
Para fins desse texto, vamos nos referir apenas às implementações para
\lang{Lua} e \lang{Python}.

\subsection{Instruções de Uso}
Aqui iremos explicar brevemente o uso da \lang{libouroboros} e do OPA, desde compilar
(usando \textit{Makefile}) até pegar valores de um \script{}, seguindo um 
simples exemplo de um programa que carrega um \script{}, pega o valor de uma
variável dele e do retorno da execução de uma função.

\subsubsection{Compilação} 
Como ainda não disponibilizamos nenhum pacote
com os binários da \lang{libouroboros}, você terá que pegar o código fonte dela
e compilá-la manualmente. Para compilar, basta rodar o CMake na pasta 
raiz do projeto para gerar seus arquivos de compilação. Então basta 
executar os comandos de make para compilação:
\begin{verbatim}
  $ cmake .
  $ make libouroboros
  $ make libouroboros-python
  $ make libouroboros-lua
\end{verbatim}
Os dois ultimos comandos são para compilar as implementações para cada linguagem,
e você deve usá-los somente se necessário. Note que apesar de a \lang{libouroboros} não
ter nenhuma dependência externa, as implementações das linguagens dependem dos
pacotes de desenvolvimento de suas respectivas linguagens de \script{}.

É também possivel simplesmente executar
\begin{verbatim}
  $ cmake .
  $ make
\end{verbatim}
Isso irá compilar a \lang{libouroboros}, \lang{libouroboros-python}, \lang{libouroboros-lua} e 
os OPWIGs correspondentes (mais sobre como usar ele na próxima seção). Caso queira, as
seguintes opções podem ser passadas para o CMake para alterar seu comportamento:
\begin{itemize}
  \item \lang{OUROBOROS\_CREATE\_BINDINGS}: se verdade, o CMake irá tentar criar as 
    implementações de linguagens (padrão é sim).
  \item \lang{OUROBOROS\_LUA\_BINDINGS}: se verdade, a implementação de \lang{Lua} será 
    habilitada (padrão é sim).
  \item \lang{OUROBOROS\_PYTHON\_BINDINGS}: se verdade, a implementação de \lang{Python}
    será habilitada (padrão é sim).
\end{itemize}

É possível também compilar os testes unitários da \lang{libouroboros}, que
criamos para testar suas funcionalidades usando o seguinte comando:
\begin{verbatim}
  $ make ouroboros_test
\end{verbatim}
E para executá-los:
\begin{verbatim}
  $ ./test/ouroboros_test
\end{verbatim}
    
\subsubsection{Ligação} 
Após compilar a \lang{libouroboros}, compile o seu código fonte e ligue-o estaticamente
com a \lang{libouroboros}, e com a \lang{libouroboros-lua} e/ou a \lang{libouroboros-python}.
    
\subsubsection{Exemplo de Código} 
Em ordem, esse exemplo inicializa o \SMgr{}, passando em qual pasta
o \SMgr{} deverá procurar por \script{s}, carrega um \script{},
pega o valor de uma variável do \script{}, seta o valor de outra variável, 
executa uma função pegando o valor de retorno, e finaliza o \SMgr{}:
    
\begin{lstlisting}
#include <opa/scriptmanager.h>
#include <opa/virtualobj.h>

using opa::VirtualObj;
using opa::ScriptManager;

int main() {
    //inicializando
    SCRIPT_MANAGER()->Initialize("./scripts/");
    
    //carregando script
    VirtualObj modulo = SCRIPT_MANAGER()->LoadModule("exemplo");
    
    //pegando variavel
    double valor_antigo = modulo["VariavelNumerica"].value<double>();
    
    //setando novo valor de variavel
    modulo["VariavelNumerica"].set_value<double>(42.0);
    
    //executando funcao
    VirtualObj funcao = modulo["Funcao"];
    VirtualObj retorno = funcao(); 
    // argumentos para a funcao sao passados como VirtualObjs, 
    // e podem ser passados quaisquer quantidade de objetos,
    // ou uma lista de VirtualObj (VirtualObj::List).
    
    //finalizando
    SCRIPT_MANAGER()->Finalize();
    delete SCRIPT_MANAGER();
    
    return 0;
}
\end{lstlisting}

Há uma coisa faltando nesse exemplo. As máquinas virtuais precisam ser registradas antes no \SMgr{}.
Enquanto os módulos gerados pelo OPWIG fazem isso automaticamente, nesse pequeno exemplo não
usamos nenhum, então temos que fazer isso manualmente. Basta fazer essas modificações no código acima:

\begin{lstlisting}
... [includes anteriores] ...
#include <opa/config.h>
#ifdef OUROBOROS_LUA_BINDINGS
#include <languages/lua/luamachine.h>
#endif
#ifdef OUROBOROS_PYTHON_BINDINGS
#include <languages/python/pythonmachine.h>
#endif

using ...

int main () {
#ifdef OUROBOROS_LUA_BINDINGS
    if (SCRIPT_MANAGER()->GetMachine("Lua") == nullptr)
        SCRIPT_MANAGER()->Register(new opa::lua::LuaMachine());    
#endif
#ifdef OUROBOROS_PYTHON_BINDINGS
    if (SCRIPT_MANAGER()->GetMachine("Python") == nullptr)
        SCRIPT_MANAGER()->Register(new opa::python::PythonMachine());
#endif

    //inicializando
    SCRIPT_MANAGER()->Initialize("./scripts/");
    
    ...
}
\end{lstlisting}

Para esse exemplo funcionar, basta ter um \script{} chamado ``\textit{exemplo}''
na pasta \textit{/scripts/}, na raiz da onde o programa será executado. A extensão
do arquivo deverá ser \textit{.lua} ou \textit{.py} para \lang{Lua} ou \lang{Python} respectivamente
(exemplo.: \textit{./scripts/exemplo.py}). Tal \script{} deverá ter uma váriavel
com um valor numérico de ponto flutuante chamada ``VariavelNumerica'', e uma função
chamada ``Funcao'' que não recebe nenhum argumento (no exemplo, o valor de retorno da
função não importa pois não é usado).

Você pode ver a robustez do OPA e de sua generalização das linguagens fazendo o seguinte:
escreva o \script{} em uma linguagem, teste, e então troque o \script{} por um na
outra linguagem, mantendo as restrições ditas acima (nome exemplo,  com uma variável, etc),
e teste novamente. O programa irá executar do mesmo modo que antes, mesmo tendo trocado a
linguagem do \script{} usado, pois a lógica é a mesma e o OPA abstrai as interfaces.


\section{Gerador de \emph{wrappers} \textbf{OPWIG}}
\label{sec:resultados:opwig}

O OPWIG é uma ferramenta com o propósito de substituir o SWIG.
Ela ainda não implementa todas funcionalidades que o SWIG tem, e portanto
ainda não consegue substituir o SWIG completamente, porém já é funcional.
As suas capacidades atuais de geração de \textit{wrappers} são:
\begin{itemize}
  \item \lang{namespaces} são traduzidos em módulos e sub-módulos na máquina
    virtual, de acordo com a estrutura dos \lang{namespaces}.
  \item Variáveis globais, possivelmente constantes.
  \item Funções globais que recebam um número qualquer de argumentos de tipos
    primitivos ou complexos (classes de usuário) e retorne nada ou um valor desses tipos.
  \item Classes simples, com:
    \begin{itemize}
      \item Destrutor.
      \item Construtor trivial (não recebe argumentos).
      \item Atributos de tipos primitivos, possivelmente constantes.
      \item Métodos não estáticos que recebam um número qualquer de argumentos
        de tipos primitivos e retorne nada ou um valor primitivo.
    \end{itemize}
\end{itemize}
Os tipos de atributos, váriaveis, paramêtros e valores devolvidos que são reconhecidos
são tanto os primitivos (naturais da linguagem nativa, como \lang{int} ou \lang{double})
quanto os complexos (classes do usuário que foram exportadas).

Além disso o código gerado pelo OPWIG também tem um bloco de inicialização
(\textit{bootstrap}) que registra a máquina virtual correspondente no \SMgr{},
caso ela não tenha sido ainda, e registra nela os módulos e sub-módulos que esse
arquivo gerado define.

É importante notar também que o código gerado pelo OPWIG depende do OPA, 
portanto qualquer programa compilado com código gerado pelo OPWIG deve ser
ligado com a \lang{libouroboros}. Isso é um contraste em relação ao SWIG, o qual gera
código sem nenhuma dependência externa. Esse comportamento foi uma decisão de
projeto que fizemos para simplificar o código gerado pelo OPWIG e sua integração
com a OPA. Supomos que se um usuário está usando o OPWIG ele provavelmente
também usará o OPA, já que nosso sistema provê essas duas vias de comunicação
entre linguagem nativa e linguagens de \script{}, enquanto o SWIG só possibilita
uma delas (a geração de \textit{wrappers}).

\subsection{Instruções de Uso}
Aqui iremos explicar como usar o OPWIG, desde compilação até execução da ferramenta
e integração do código gerado com seu programa.

Note que enquanto nos referimos ao OPWIG como ``uma'' ferramenta, ele na verdade
é uma biblioteca. Por simplicidade de código e organização do sistema, 
todo o código do OPWIG é compilado junto com o OPA na \lang{libouroboros}, enquanto que 
a implementação do OPWIG para cada linguagem é compilada com a implementação do
OPA para cada linguagem. Como por exemplo, na \lang{libouroboros-lua}.

Então para de fato usar o OPWIG é necessário um outro arquivo de código, compilado
num executável separado, que execute o OPWIG para uma linguagem de \script{} especifica.
Como mencionamos na seção \ref{cap:atividades:cmake}, esses arquivos de código podem
ser gerados automaticamente pelo CMake, e seguem o seguinte padrão:
\begin{lstlisting}
#include <opwig/opwig.h>

// Inclui o header para a especificacao da linguagem de script em questao
#include <...header da especificacao da linguagem...>

int main (int argc, char** argv) {
    // O parametro do template LanguageSpecification nesta chamada de funcao
    // devera ser a classe da especificacao da linguagem de script.
    return opwig::gen::Execute< LanguagenSpecification >(argc, argv);
}
\end{lstlisting}
Tais executáveis são as ferramentas de fato, e cada um deverá ser ligado junto com a
\lang{libouroboros} e a implementação da \lang{libouroboros} para a linguagem de \script{} em questão. 
Damos o nome de ``opwig-linguagem'' para esses executáveis do OPWIG, como por exemplo
\textbf{opwig-lua} e \textbf{opwig-python}.

A interface do OPWIG disponibilizada pela \lang{libouroboros} e os módulos de CMake
que criamos fazem essa terefa de criar executáveis do OPWIG para cada linguagem ser trivial,
e o CMake do Ouroboros já usa desse dispositivo para definir o \lang{opwig-lua} e 
\lang{opwig-python}.

\subsubsection{Compilação}
Como ainda não disponibilizamos um pacote com as ferramentas prontas, será necessário
compilar os OPWIGs. Para tal, basta usar o CMake tal como já explicamos anteriormente:
\begin{verbatim}
  $ cmake .
  $ make opwig-lua
  $ make opwig-python
\end{verbatim}
E lembrando que o comando \lang{make} (sem parâmetros) compila ambos OPWIG juntamente com
as \lang{libouroboros}.

O \lang{opwig-lua} depende da \lang{libouroboros-lua}, e analogamente o \lang{opwig-python}
depende da \lang{libouroboros-python}.

É possível também compilar o extenso conjunto de testes unitários do OPWIG, que
criamos para testar suas funcionalidades usando o seguinte comando:
\begin{verbatim}
  $ make opwig_test
\end{verbatim}
E para executá-los:
\begin{verbatim}
  $ ./test/opwig_test
\end{verbatim}

\subsubsection{Execução}
Após compilado, executar o programa é simples:
\begin{verbatim}
  $ opwig-python --module-name=NOME ARQUIVO-1 ARQUIVO-2 ... ARQUIVO-N
\end{verbatim}
Onde:
\begin{itemize}
  \item \textbf{opwig-python} é o OPWIG em questão, troque para qual OPWIG você quer executar 
    (outro exemplo seria o \lang{opwig-lua}).
  \item \textbf{NOME}: é o nome do módulo que será gerado.
  \item \textbf{ARQUIVO-i}: são os arquivos de cabeçalho em \CXX{} que contêm a interface
    que você deseja que seja exportada no módulo.
\end{itemize}

Cada ferramenta do OPWIG é especifica para uma linguagem e portanto ao ser executado
ele obrigatoriamente irá gerar um arquivo de código com o módulo exportado para a
linguagem de \script{} respectiva. Ele gera o arquivo na mesma pasta de onde ele está 
sendo executado, seguindo o seguinte padrão de nomenclatura:
\begin{verbatim}
  <nome da linguagem de script>_<nome do módulo>_wrap.cxx
\end{verbatim}

\subsubsection{Usando os módulos gerados}
Para usar os módulos gerados, basta compilar eles junto com seu programa, ligado com
a \lang{libouroboros} e com suas implementações específicas que forem desejadas e
necessárias.

Qualquer \script{} em uma linguagem compatível que seja carregado pelo seu programa
(usando a OPA) será capaz de incluir o módulo gerado usando o sistema padrão da
linguagem para inclusão de módulos externos. E o módulo em si deverá ser
usado como qualquer outro módulo dessa linguagem.
