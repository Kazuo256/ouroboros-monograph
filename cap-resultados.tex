\chapter{Resultados}
\label{cap:resultados}

Neste capítulo iremos apresentar os resultados obtidos ao longo do
desenvolvimento do Projeto Ouroboros. Parte desses resultados foram
obtidos antes do trabalho de formatura, mas ainda assim foram aprimorados
durante a evolução do trabalho. Esses resultados formam o que
chamamos de sistema do Projeto Ouroboros, na forma de uma biblioteca \CXX{}
de nome \lang{libouroboros}. Como vimos no capítulo \ref{cap:estrutura},
ele é composto por duas grandes partes, uma responsável por incorporar
\script{s} e outra por exportar funcionalidades nativas para \script{s}.
São a OPA e o OPWIG, resepectivamente.

Para deixar clara a separação entre eles, os cabeçalho da biblioteca
dividem a interface dela em dois \textit{namespaces}: \lang{opa} e \lang{opwig}.
Normalmente, quando o usuário usar nosso sistema, ele limitar-se-á ao uso
das classes e rotinas do primeiro. Mas o segundo ainda se faz necessário
para que os geradores de \textit{wrappers} funcionem apropriadamente.

Nossa intenção é que a \lang{libouroboros} seja facilmente compilada em várias plataformas
usando o CMake para gerar arquivos relativos à compilação, como \textit{Makefile}s
no Linux. Não chegamos a testar em Mac OS mas por enquando em Windows não é
possível compilar usando Visual Studio porque ele não reconhece \CXX{11} completamente
ainda. Em Linux, contanto que os pacotes necessários estejam instalados, a biblioteca
compila e funciona sem problemas.

As implementações que fizemos da OPA e do OPWIG que comportam as linguagens de
\script{} \lang{Lua} e \lang{Python} também estão funcionais (embora ainda não
com todas as funcionalidades que gostaríamos), sendo distríbuidas como extensões
da \lang{libouroboros} na forma outras bibliotecas separadas: \lang{libouroboros-lua}
e \lang{libouroboros-python}, para \lang{Lua} e \lang{Python}, respectivamente.
Assim é fácil incluí-las em uma mesma aplicação, basta ligá-la com a
\lang{libouroboros} e com elas. Caso o usuário não queira usar uma das linguagens,
é só não ligar com a biblioteca correspondente. Caso ele queira alguma outra
linguagem, é só ele obter a implementação da \lang{libouroboros} específica dela
e ligá-la junto.

\section{OPA}
\label{cap:resultados:opa}

Dentre as duas partes, apenas a OPA está com praticamente todas as
funcionalidades desejadas implementadas. Como descrito nos capítulos
anteriores, ela inclui um sistema para gerenciar as máquinas virtuais
e incorporar \script{s} independente de sua linguagem, tudo com uma
interface simples, genérica e robusta para que o usuário de \CXX{} possa
trabalhar sem se preocupar com os pormenores dos serviços fornecidos. É
provável que ainda alteremos algumas coisas no sistema, arrumando os
eventuais erros que surgirem ou implementando novas funcionalidades.

\subsection{Instruções de Uso}
Aqui iremos explicar brevemente como usar a OPA da \lang{libouroboros}. Como
essa é a única parte que o usuário irá usar diretamente da biblioteca, também
explicamos aqui como compilá-la usando CMake e Makefile. Depois mostraremos
um simples exemplo de um programa que carrega um \script{}, pega o valor de uma
variável dele e do resultado da execução de uma função.

\subsubsection{Compilação} 
Como ainda não disponibilizamos nenhum pacote
com os binários da \lang{libouroboros}, você terá que obter o código fonte dela
e compilá-la manualmente. Para compilar, basta rodar o CMake na pasta 
raiz do projeto que ele gerará os arquivos de compilação necessáios.
E então, basta executar os comandos de make para compilação:

\begin{verbatim}
  $ cmake .
  $ make libouroboros
  $ make libouroboros-python
  $ make libouroboros-lua
\end{verbatim}

Os dois ultimos comandos são para compilar as implementações para cada linguagem,
e você precisa usá-los somente se quiser de fato elas. Note que apesar de a
\lang{libouroboros} não ter nenhuma dependência externa, as implementações
das linguagens dependem dos pacotes de desenvolvimento de suas respectivas
linguagens de \script{}, pois eles contêm a implementação das APIs das máquinas virtuais.
É também possivel simplesmente executar

\begin{verbatim}
  $ cmake .
  $ make
\end{verbatim}

Isso irá compilar a \lang{libouroboros}, \lang{libouroboros-python}, \lang{libouroboros-lua} e 
os geradores correspondentes (mais sobre como usar eles na próxima seção). Caso queira, as
seguintes opções podem ser passadas para o CMake para alterar seu comportamento:

\begin{itemize}
  \item \lang{OUROBOROS\_CREATE\_BINDINGS}: quando ativada, o CMake irá tentar criar as 
    implementações específicas de cada linguagens.
  \item \lang{OUROBOROS\_LUA\_BINDINGS}: quando ativada, a implementação de \lang{Lua} será 
    habilitada.
  \item \lang{OUROBOROS\_PYTHON\_BINDINGS}: quando ativada, a implementação de \lang{Python}
    será habilitada.
\end{itemize}

O padrão é todas elas estarem ativadas. É possível também compilar os testes unitários da
OPA, que criamos para testar suas funcionalidades, usando o seguinte comando:

\begin{verbatim}
  $ make opa_test
\end{verbatim}

E para executá-los:

\begin{verbatim}
  $ ./test/opa_test
\end{verbatim}

Uma vez compilada a \lang{libouroboros}, lembre-se de incluir os cabeçalhos necessários
no código de sua aplicação e de ligar as bibliotecas com ela, além de ligar também
com a \lang{libouroboros-lua} e/ou a \lang{libouroboros-python}.
    
\subsubsection{Exemplo de Código} 
Nesse exemplo, o programa começa inicializando o gerenciador, especificando a pasta na qual
ele deverá procurar por \script{s} (linha 9). Depois ele carrega um \script{} (linha 12),
pega o valor de uma variável de dentro dele (linha 15), muda o valor dessa variável (linha 18),
e executa uma função que fornece um valor de resultado (linhas 21-22). Por fim, ele finaliza o
gerenciador (linhas 28-29):
    
\begin{lstlisting}
#include <opa/scriptmanager.h>
#include <opa/virtualobj.h>

using opa::VirtualObj;
using opa::ScriptManager;

int main() {
    //inicializando
    SCRIPT_MANAGER()->Initialize("./scripts/");
    
    //carregando script
    VirtualObj modulo = SCRIPT_MANAGER()->LoadModule("exemplo");
    
    //pegando variavel
    double valor_antigo = modulo["number"].value<double>();
    
    //mudando o valor da variavel
    modulo["number"].set_value<double>(42.0);
    
    //executando funcao
    VirtualObj funcao = modulo["DoStuff"];
    VirtualObj retorno = funcao(); 
    // argumentos para a funcao sao passados como VirtualObjs, 
    // e podem ser passados quaisquer quantidade de objetos,
    // ou uma lista de VirtualObj (VirtualObj::List).
    
    //finalizando
    SCRIPT_MANAGER()->Finalize();
    delete SCRIPT_MANAGER();
    
    return 0;
}
\end{lstlisting}

Esse exemplo omite a inicialização das máquinas virtuais. Elas precisam ser registradas antes
de o gerenciador ser inicializado. Os \textit{wrappers} gerados pelo OPWIG fazem isso automaticamente,
mas como nesse pequeno exemplo não usamos nenhum, temos que fazer isso manualmente. Basta fazer essas
modificações no código acima:

\begin{lstlisting}
... [includes anteriores] ...
#include <opa/config.h>
#ifdef OUROBOROS_LUA_BINDINGS
#include <languages/lua/luamachine.h>
#endif
#ifdef OUROBOROS_PYTHON_BINDINGS
#include <languages/python/pythonmachine.h>
#endif

using ...

int main () {
#ifdef OUROBOROS_LUA_BINDINGS
    if (SCRIPT_MANAGER()->GetMachine("Lua") == nullptr)
        SCRIPT_MANAGER()->Register(new opa::lua::LuaMachine());    
#endif
#ifdef OUROBOROS_PYTHON_BINDINGS
    if (SCRIPT_MANAGER()->GetMachine("Python") == nullptr)
        SCRIPT_MANAGER()->Register(new opa::python::PythonMachine());
#endif

    //inicializando
    SCRIPT_MANAGER()->Initialize("./scripts/");
    
    ...
}
\end{lstlisting}

Os \lang{ifdef}s usarão as configurações que estavam ativadas no CMake para
determinar quais máquinas virtuais devem ser registradas, e quais cabeçalhos
precisam ser inclusos para tanto.

Finalmente, para esse exemplo funcionar é necessário um \script{} como o seguinte,
em \lang{Python}:

\begin{lstlisting}[language=python]
#exemplo.py

number = 1138.0

def DoStuff():
    return "coisas foram realizadas"
\end{lstlisting}

ou esse, em \lang{Lua}:

\begin{lstlisting}[language=lua]
--exemplo.lua

number = 1138.0

function DoStuff()
    return "coisas foram realizadas"
end
\end{lstlisting}

E é ai que você pode ver a robustez da OPA e de sua generalização das linguagens.
Nesse exemplo você pode usar tanto o \script{} em \lang{Lua} como o \script{} em
\lang{Python} e o código \CXX{} não será alterado e irá funcionar do mesmo jeito.

\section{OPWIG}
\label{cap:resultados:opwig}

Essa é a parte com o propósito de substituir o SWIG.
Ela ainda não implementa todas funcionalidades que ele tem, e portanto
ainda não consegue substituí-lo, porém já é funcional.
As estruturas \CXX{} que ela é atualmente capaz de exportar nos \textit{wrappers}
gerados são:

\begin{itemize}
  \item \textbf{\textit{Namespaces}}, que são traduzidos em módulos e sub-módulos
        na máquina virtual, de acordo com a hierarquia que eles apresentam.
  \item \textbf{Variáveis globais}, possivelmente constantes.
  \item \textbf{Funções globais}
  \item \textbf{Classes simples}, com:
    \begin{itemize}
      \item Destrutor.
      \item Construtor trivial (não recebe argumentos).
      \item Atributos, possivelmente constantes.
      \item Métodos não estáticos.
    \end{itemize}
\end{itemize}

Os tipos de atributos, váriaveis, paramêtros e valores devolvidos que são reconhecidos
são tanto os primitivos (naturais da linguagem nativa, como \lang{int} ou \lang{double})
quanto os complexos (classes do usuário que foram exportadas junto). Além disso o código
gerado pelo OPWIG também tem, como dissemos no capítulo anterior, um bloco de inicialização
(\textit{bootstrap}) que registra a máquina virtual correspondente no gerenciador,
caso ela não tenha sido ainda, e registra nela os módulos e sub-módulos que esse
arquivo gerado visa exportar.

É importante notar também que os código gerado pelo OPWIG depende de algumas funcionalidade
presentes na OPA, portanto qualquer programa compilado junto com o código gerado por ele deve
ser ligado com a \lang{libouroboros}. Isso é um contraste em relação ao SWIG, o qual gera
código sem nenhuma dependência externa. Esse comportamento foi uma decisão de
projeto que fizemos para simplificar o código gerado pelo OPWIG e garantir uma melhor integração
com a parte de incorporação. Supomos que se um usuário está usando o OPWIG então ele provavelmente
também usará a OPA, já que o maior diferencial do nosso sistema com relação ao SWIG é que aquele provê
essas duas vias de comunicação entre linguagem nativa e linguagens de \script{} enquanto que este
apenas fornece a geração de \textit{wrappers} para exportação.

\subsection{Instruções de Uso}
Aqui iremos explicar como usar o OPWIG, desde a compilação dos geradores até a execução
deles e a inclusão do código gerado em sua aplicação.

É importante lembrar que o OPWIG na verdade é uma parte da nossa biblioteca. Por
simplicidade de código e organização do sistema, todo o código do OPWIG é compilado
junto com a OPA na \lang{libouroboros}. Cada extensão individual para linguagens de \script{}
(no caso, a \lang{libouroboros-lua} e a \lang{libouroboros-python}) deve
fornecer a sua especificação de \textit{wrappers} para que o OPWIG saiba como gerá-los.
Depois, para de fato usá-lo é necessário um outro arquivo de código, compilado
como um executável separado, que use a especificação desejada quando evocar as rotinas
do OPWIG. Como mencionamos na seção \ref{cap:atividades:cmake}, esses arquivos de código
são gerados automaticamente pelo CMake, pois eles seguem o seguinte padrão:

\begin{lstlisting}
#include <opwig/opwig.h>

// Inclui o cabecalho para a especificacao de wrappers da maquina virtual em questao
#include <...header da especificacao da linguagem...>

int main (int argc, char** argv) {
    // O parametro do template LanguageSpecification nesta chamada de funcao
    // devera ser a classe que implementa a especificacao wrappers.
    return opwig::gen::Execute< LanguagenSpecification >(argc, argv);
}
\end{lstlisting}

%TODO mostrar o que precisa colocar no cmake para um extensao ter seu gerador gerado

Tais executáveis são os geradors de fato, e cada um deverá ser ligado junto com a
\lang{libouroboros} e as extensões dela que a linguagem de \script{} em questão exige. 
Esses geradores são gerados com um nome de prefixo \lang{opwig-} seguido pelo nome da
linguagem de \script{} para a qual eles exportam. A interface do
OPWIG disponibilizada pela \lang{libouroboros} e os módulos de CMake que criamos fazem a
terefa de criar executáveis do OPWIG para cada linguagem ser trivial, e as listas de CMake
do repositório do projeto já usam essas facilidades para construir o \lang{opwig-lua}
e o \lang{opwig-python}.

\subsubsection{Compilação}
Como ainda não disponibilizamos um pacote com as ferramentas prontas, será necessário
compilar os geradores. Para tal, basta usar o CMake como acabamos de explicar:

\begin{verbatim}
  $ cmake .
  $ make opwig-lua
  $ make opwig-python
\end{verbatim}


O \lang{opwig-lua} depende da \lang{libouroboros-lua}, e analogamente o \lang{opwig-python}
depende da \lang{libouroboros-python}, então eles precisam estar disponíveis no sistema.
Vale lembrar que também é possível compilar os geradores juntos com a
\lang{libouroboros} e suas extensões padrões usando:

\begin{verbatim}
  $ cmake .
  $ make
\end{verbatim}

É possível também compilar o extenso conjunto de testes unitários do OPWIG, que
criamos para testar suas funcionalidades, usando o seguinte comando:

\begin{verbatim}
  $ make opwig_test
\end{verbatim}

E para executá-los:

\begin{verbatim}
  $ ./test/opwig_test
\end{verbatim}

\subsubsection{Execução}

Após compilado, executar um dos geradores é simples:
\begin{verbatim}
  $ opwig-* --module-name=NOME ARQUIVO-1 ARQUIVO-2 ... ARQUIVO-N
\end{verbatim}

Onde:
\begin{itemize}
  \item \textbf{opwig-*} é o OPWIG em questão. Você precisa especificar a
        linguagem para a qual você quer exportar (por exemplo, \lang{opwig-python}
        para o gerador de \textit{wrappers} para \lang{Python}).
  \item \textbf{NOME}: é o nome do módulo que será gerado.
  \item \textbf{ARQUIVO-i}: são os arquivos de cabeçalho em \CXX{} que contêm a interface
        que você deseja que seja exportada no módulo.
\end{itemize}

Cada gerador é especificado para uma só linguagem e portanto ao ser executado
ele obrigatoriamente irá gerar um arquivo de código com o módulo exportado para a
essa linguagem apenas. O arquivo gerado é criado na mesma pasta onde gerador foi
executado, seguindo o seguinte padrão de nomenclatura:
\begin{verbatim}
  <nome da linguagem de script>_<nome do módulo>_wrap.cxx
\end{verbatim}

Alternativamente, você pode optar por usar CMake para compilar sua aplicação, o que
lhe permite usar as funcionalidades descritas na seção \ref{cap:atividades:cmake}
para automatizar todo esse procedimento.

\subsubsection{Usando os módulos gerados}

Para usar os módulos gerados, basta compilar eles junto com seu programa, ligado com
a \lang{libouroboros} e com as extensões necessárias. Qualquer \script{} em uma
linguagem compatível que for incorporado ao seu programa (usando a OPA) será
capaz de incluir o módulo gerado usando o mecanismo padrão da linguagem para
inclusão de módulos externos. E o módulo em si deverá ser usado como qualquer
outro módulo normal dessa linguagem.

Por exemplo, suponha a seguinte interface em \CXX{}:
\begin{lstlisting}
// coisas.h

const char* prefixo = "Supimpa";

namespace funcoes {
    void FazAlgumaCoisa(int n);
}

namespace objetos {

    class Coisa {
      public:
        Coisa();
        ~Coisa();
        
        Coisa* PegaCoisa( const char* nome );
        void ColocaCoisa(Coisa* coisa);
        
        double fator;
    };
}
\end{lstlisting}

Sendo exportada como um módulo de nome ``coisas'', essa interface pode ser usada em \lang{Python}
da seguinte forma:

\begin{lstlisting}[language=python]
import coisas

c = coisas.objetos.Coisa()
c2 = c.PegaCoisa( coisas.prefixo + "Batuta" )
c.ColocaCoisa( coisas.objetos.Coisa() )

coisas.funcoes.FazAlgumaCoisa( 42 * c.fator )
\end{lstlisting}

Ou em \lang{Lua} assim:
\begin{lstlisting}[language=lua]
require "coisas"

c = coisas.objetos.Coisa()
c2 = c:PegaCoisa( coisas.prefixo .. "Batuta" )
c:ColocaCoisa( coisas.objetos.Coisa() )

coisas.funcoes.FazAlgumaCoisa( 42 * c.fator )
\end{lstlisting}
