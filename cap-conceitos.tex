
\chapter{Conceitos e tecnologias estudadas}
\label{cap:conceitos}
  Sempre que encontramos um problema, buscamos uma solução. Muitos dos produtos
  que usamos diariamente são a manifestação dessas soluções que alguém projetou
  para lidar com os empecilhos do dia-a-dia, desde uma mobília para conseguirmos
  sentar e comer até aparelhos elaborados para detectar doenças em nossos
  corpos. Entender o problema que se quer resolver, e saber desprender a solução
  dessa análise é um procedimento fundamental ao projetar esses produtos -- o
  mesmo vale quando desenvolvemos um \textit{software}. Para tanto, existem
  várias maneiras de se modelar os problemas, e uma das mais simples é na forma
  de uma pergunta.

  \emph{Como integrar \CXX{} com linguagens de \script{}?} Um dos primeiros
  conceitos com o qual aspirantes a programadores têm que se habituar é que
  programas são o resultado de um código misterioso escrito usando uma dessas
  chamadas linguagens de programação. A partir desse momento, costuma-se passar
  por aquele período onde se acredita que a quantidade de linguagens dominadas
  define uma métrica das habilidades do programador ou da programadora, e
  ficamos maravilhados pela miríade de linguagens diferentes. Até que entendemos
  que por trás de todas elas a ideia é relativamente a mesma, naquele momento em
  que percebemos que ``ah, então é assim que se faz um laço nessa linguagem''.
  
  Mas anedotas à parte, permanece o fato de que cada linguagem de programação
  funciona através do seu próprio mecanismo de implementação. Como seria
  possível qualquer tipo de integração entre elas, então? Esse capítulo tem
  como objetivo esclarecer essa questão, e com isso destacar o problema que
  o nosso sistema foi projetado para resolver, além do método necessário para
  tanto. Começamos tentando entender melhor o que são esses elementos que
  estamos tentando integrar.

  \section{Linguagens de Programação}
  \label{cap:conceitos:linguagens}
    Uma das coisas mais importantes que todo programador aprende cedo ou tarde é
    que computadores \emph{não são máquinas inteligentes}. Eles fazem apenas e
    exatamente aquilo que mandamos eles fazerem\footnote{A menos de problemas de
    \textit{hardware}, é claro.}. Por outro lado, é isso que torna eles mais
    confiáveis que humanos no que diz respeito a muitas atividades. E o que
    explica essa característica intrínsica dos computadores é que eles operam
    através de instruções \cite{cpp:00}.

    Quando recebemos uma instrução, tipicamente nos está sendo pedido para
    realizar uma ação, possivelmente envolvendo objetos ou outras pessoas. Com o
    computador, as ações que lhe são instruídas envolvem dados
    \cite{org&arch:00}. As transformações e manipulações que ele pode executar
    sobre dados, assim como o que os dados podem representar compõem o que
    chamamos de \textbf{modelo computacional}, pois indicam as possíveis
    \textbf{computações} que podem ser realizadas dentro de tal modelo. Por sua
    vez, dizemos que as intruções que especificam a computação que desejamos que
    o computador faça formam um \textbf{programa}. Finalmente, isso leva ao
    nosso objeto de interesse: para expressar esse programa ao computador usamos
    uma \textbf{linguagem de programação}. De maneira mais formal, podemos
    definir os termos acima conforme \cite{pl:00}:

    \vspace{2em}

    \definicao{
      \vspace{-1.5em}
      \begin{enumerate}
        \item Um \textbf{modelo computacional} é uma coleção de valores e
              operações.
        \item Uma \textbf{computação} é a aplicação de uma sequência de
              operações sobre um valor para obter outro valor.
        \item Um \textbf{programa} é a especificação de uma computação.
        \item Uma \textbf{linguagem de programação} é uma notação para escrever
              programas.
      \end{enumerate}
    }
    
    Essencialmente, linguagens de programação são a maneira que se encontrou
    para deixar claro quais instruções o computador deve seguir, visto que ele
    as seguirá à risca e portanto queremos ter certeza do que lhe estamos
    pedindo. Agora, se queremos integrar linguagens, precisamos entender como
    são seus modelos computacionais e como interagir com eles na prática. No
    caso, estamos mais especificamente interessados em \CXX{} e em linguagens de
    \script{}. Então vamos estudar, nas próximas sessões, as características que
    elas possuem, assim como as possibilidades que elas nos oferecem.

  \section{Da linguagem para a máquina}
  \label{cap:conceitos:maquina}

    O processo que leva do programa escrito à sua execução pelo computador pode
    ocorrer de diversas maneiras. A mais direta é quando a linguagem usada é
    exatamente aquela que o computador foi projetado para processar. Em geral,
    uma linguagem dessas usa apenas valores numéricos para representar
    instruções explícitas de \emph{hardware} para manipulação de dados brutos,
    e são conhecidas como \textbf{linguagem de máquina} \cite{org&arch:00}.
    Para elas, o modelo computacional corresponde às operações que o processador
    é capaz de executar e os dados que podem ser armazenados nos diversos tipos
    de memória da máquina.

    \definicao{
      \textbf{Linguagem de máquina} é toda linguagem de programação que é
      processada diretamente por uma máquina como um computador.
    }
    
    Como é de se imaginar, desenvolver com essas linguagens não é exatamente uma
    tarefa simples. Cada arquitetura de computador possui uma versão própria
    delas, tornando trabalhoso de fazer um mesmo programa compatível com todas
    elas. Além disso, é preciso muitas instruções para realizar computações
    simples, pois as operações que um processador é capaz de fazer são
    normalmente bastante primitivas - como movimentar dados na memória, ou
    comparar o valor dos dados em lugares diferentes dela. Para lidar com esses
    problemas existem dois métodos que essencialmente buscam abstrair as
    computações desejadas em instruções mais abstratas, isso é, em uma linguagem
    de programação mais acessível - ou de alto nível, como se costuma dizer.

    \subsection{Compilação}
    \label{cap:conceitos:maquina:compilacao}

    O primeiro e mais tradicional deles é traduzir programas escritos nessa
    nova linguagem para a linguagem de máquina do computador alvo. E,
    obviamente, não queremos fazer essa tradução nós mesmos, mas sim desenvolver
    um programa que a faça por nós. Programas assim são ditos
    \textbf{compiladores}, pois eles \emph{compilam} a linguagem fonte para o
    linguagem objeto. Nesse caso, também dizemos que a linguagem fonte é uma
    \textbf{linguagem compilada}.
    
    \definicao{
      \vspace{-1.5em}
      \begin{enumerate}
        \item \textbf{Compiladores} são programas que traduzem uma linguagem
              fonte de alto nível em uma linguagem objeto mais próxima de uma
              linguagem de máquina.
        \item Uma \textbf{linguagem de programação compilada} é a linguagem
              fonte de um compilador.
      \end{enumerate}
    }
    
    Em particular, \CXX{} é uma linguagem compilada \cite{cpp:00}. Em suas
    primeiras versões programas escritos nela eram compilados para a linguagem
    \C{}, que por sua vez compilam para linguagens bastante próximas de uma
    linguagem de máquina, conhecidas como linguagens de montagem; atualmente,
    \CXX{} é compilado diretamente para essas linguagens também \cite{cpp:01}.
    Isso significa que uma das linguagens que estamos tentando integrar no fundo
    é basicamente uma linguagem de máquina disfarçada de maneira bastante
    elegante.
    
    Para que mais de um programa escritos em uma linguagem assim
    possam unir suas funcionalidades, é preciso duas coisas. Primeiramente, pelo
    menos um deles tem que conhecer os símbolos\footnotemark{} relevantes do
    outro; ou seja, o código que declara esses símbolos deve estar incluso no
    programa que os usará. A segunda parte envolve, uma vez que os programas
    estejam compilados para o código objeto, ligar esses símbolos importados às
    suas respectivas definições no programa de origem deles. Isso é feito por um
    programa à parte, chamado de \emph{ligador}, ou pelo próprio compilador. A
    maneira que tanto \C{} quanto \CXX{} encontraram para lidar com esse
    procedimento foi fornecer uma divisão para seus arquivos de código fonte:
    uma parte seriam os \emph{arquivos de cabeçalho} - onde os símbolos são
    declarados - e a outra seriam os \emph{arquivos de implementação} - onde a
    definição do que os símbolos significam é feita.

    \footnotetext{
      Esses símbolos são essenciamente nomes que estão associados a partes
      específicas de um programa, como suas variáveis e rotinas.
    }

    Isso permite que as partes de um programa com rotinas interrelacionadas
    possam ser compiladas em programas menores para ser ligados juntos depois,
    e assim apenas parte do programa precisa ser recompilada se só ela for
    modificada. Também fica possível fazer um programa auxiliar que possa ser
    ligado com qualquer outro que precise de suas funcionalidades, que é o que
    chamamos de uma \emph{biblioteca}. A desvantagem de tudo isso são as
    restrições impostas ao processo de desenvolvimento: tanto o compilador
    quanto o ligador (quando necessário) precisam estar à disposição e
    devidamente configurados, e as bibliotecas necessárias devem estar
    acessíveis a eles.

    \subsection{Interpretação}
    \label{cap:conceitos:maquina:interpretacao}

    O segundo método de usar uma linguagem de alto nível para abstrair
    linguagens próximas a linguagens de máquina seria providenciar um programa
    intermediário capaz de simular a execução de instruções. Chamamos esses
    programas de \textbf{interpretadores} \cite{pl:00}. Também dizemos que sua
    linguagem fonte é uma \textbf{linguagem interpretada}. Essencialmente, ao
    invés de tentar levar a linguagem em si para mais perto da máquina, eles
    trazem a máquina para mais perto da linguagem. Isso é, produzem um modelo
    computacional virtual ao invés de serem computadores reais, porém continuam
    igualmente expressivos. Para tanto, eles simulam uma máquina condizente
    dentro de si, constituindo o que é conhecido como uma \textbf{máquina virtual}.

    \definicao{
      \vspace{-1.5em}
      \begin{enumerate}
        \item Uma \textbf{máquina virtual} é uma simulação de um modelo
              computacional dentro de um programa.
        \item \textbf{Interpretadores} são programas que processam uma linguagem
              fonte de alto nível usando uma máquina virtual.
        \item Uma \textbf{linguagem de programação interpretada} é a linguagem
              fonte de um interpretador.
      \end{enumerate}
    }

    Uma das grandes e principais vantagens de linguagens interpretadas é que
    suas abstrações podem produzir muito mais escrevendo muito menos. Outra
    vantagem é que como elas são processadas por um programa durante a execução
    deste, então o código fonte não precisa estar completo imediatamante (como
    ocorre com a compilação). O interpretador pode ir recebendo as intruções uma
    de cada vez, conforme o usuário as digita nas famosas linhas de comando, por
    exemplo. Juntando essas duas  características, é possível um usuário
    utilizar um terminal para acessar seu sistema operacional através de uma
    linguagem interpretada, mas também manter uma coleção de arquivos escritos
    na mesma linguagem implementando algumas rotinas comuns e repetitivas para
    que ele ou ela possa executá-los quando for mais conveniente. São esses
    arquivos auxiliares que chamamos de \textbf{\script{s}} (do inglês,
    ``roteiros'').

    Costumamos dizer que linguagens interpretadas que podem ser usadas
    para escrever \script{s} são \textbf{linguagens de \script{}}. Infelizmente
    não é tão fácil definir formalmente elas, como indica \cite{script:00}. O
    que não chega a ser um problema para nossa discussão, pois as propriedades
    que nos interessam estão na definição das linguagens interpretadas.

    E, com isso, chegamos às outras linguagens que queremos integrar:
    \lang{Lua}\footnote{Versão 5.1, vide \cite{lua:00}} e
    \lang{Python}\footnote{Versão 2.7, vide \cite{python:00}}, ambas
    consideradas linguagens de \script{}. Com o objetivo de encontrar um meio de
    usá-las junto com \CXX{}, fizemos uma pesquisa sobre o funcionamento de suas
    respectivas máquinas virtuais. O que descobrimos, para nossa felicidade, é
    que ambas são bibliotecas desenvolvidas em \C{}, e que seus interpretadores
    nada mais são do que programas que usam essas bibliotecas. Eles cuidam de
    receber o código do usuário, seja através da linha de comando ou de
    \script{s}, e passá-los para a máquina virtual, que os processa devidamente.
    
    Então, obtivemos finalmente um meio de possivelmente resolver o problema
    proposto no começo desse capítulo. \CXX{} talvez possa ser integrado com
    \lang{Lua} ou \lang{Python} se um programa escrito nele for compilado e
    ligado junto com as bilbiotecas dessas linguagens, obtendo assim acesso às
    suas respectivas máquinas virtuais. Tendo isso em mente, vamos buscar
    esclarecer o funcionamento dessas bibliotecas na sessão a seguir, antes de
    passarmos para a solução que propusemos no projeto em si.

  \section{As bibliotecas de \lang{Lua} e \lang{Python}}
  \label{cap:conceitos:apis}

    Aqui terá uma explicação feliz sobre o que são APIs.

    \subsection{\lang{Lua}}

      Lua funciona com uma pilha AA...
      Não precisa gerenciar memória...

      Por exemplo, para chamar um função, fazemos isso: ...

      O esquema de módulos é o seguinte...

    \subsection{\lang{Python}}
    Ao contrário de Lua, Python trabalha internamente com um \emph{heap} para guardar seus objetos.
    Porém raramente o usuário precisa mexer com o heap diretamente. De fato, ao longo do desenvolvimento
    desse projeto nunca precisamos mexer nele.
    
    A API \C{} do Python é bem compreensiva e documentada, com muitas funções e macros para ajudar 
    o usuário, nos diversos aspectos da interação com a máquina virtual, como conversão de valores,
    tratamento de objetos e de diversos ``protocolos'' que os objetos podem usar, como o
    protocolo de sequência (uma lista ou uma tupla em Python, por exemplo, usam esse protocolo) -
    facilitando o uso de sequências pelo código \C{}.
    
    Por exemplo, suponha o seguinte script Python, :
    \lstset{language=Python}
    \begin{lstlisting}
    # teste.py
    def pow(x,y):
        return x**y
    \end{lstlisting}
    \lstset{language=C++}
    
    Para executar a função \emph{pow} em \CXX{} fazemos o seguinte:
    \begin{lstlisting}
    #include <Python.h>
    
    double executaPow(double x, double y) {
        //primeiro importamos o modulo
        PyObject* teste = PyImport_ImportModule("teste"); //new ref
        
        //gracas a facilidade da API, com uma unica chamada podemos
        // 1. pegar uma funcao do modulo
        // 2. construir uma tupla com os parametros a serem passados
        // 3. executar a tal funcao, passando os parametros.
        //e tambem possivel realizar essas operacoes separadamente,
        //cada uma e uma outra chamada de funcao da API.
        PyObject* result = PyObject_CallMethod(teste, "pow", "(dd)", x, y); //new ref
        
        //convertermos o resultado para C
        double resultado = PyFloat_AsDouble(result);
        
        //corrigimos as contagens de referencia
        Py_DECREF(teste);
        Py_DECREF(result);
        
        //e retornamos o resultado
        return resultado;
    }
    \end{lstlisting}
    
    Como é possível notar no exemplo acima, outra facilidade da API é ela usa um sistema 
    primitivo de orientação a objetos em \C{}, e quase tudo em Python (um módulo, uma 
    classe, uma função, etc) é representado em \C{} por um ponteiro para \emph{PyObject}, 
    que além de informações sobre o tipo do objeto e outros valores, contém a contagem de 
    referência do objeto. Quando a contagem de referências de um objeto se torna zero, a 
    máquina virtual deleta aquele objeto. E ai está um dos piores pontos da API Python: 
    enquanto a máquina virtual gerencia automaticamente as contagens de referência
    quando ela processa código em Python, o usuário que usar a API \C{} tem incrementar e 
    decrementar manualmente as contagens dos objetos que ele está usando, o que é trabalhoso e 
    propenso a erros.
    
    
