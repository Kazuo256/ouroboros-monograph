
\chapter{Conceitos Necessários}
\label{cap:conceitos}

  O que significa integrar linguagens de programação? O que faz uma dessas
  linguagens ser uma \textbf{linguagem de \script{}} ou não? Como isso interfere
  no desenvolvimento da ferramenta que apresentamos aqui? É com o intuito de
  responder essas questões que fizemos esse capítulo. Nele, apresentamos a
  teoria e os conceitos por trás do nosso projeto.

  Começamos esclarecendo a ideia geral do que é uma linguagem de programação -
  na seção \ref{cap:conceitos:linguagens} - e de como programas escritos com
  elas podem ser executados - na seção \ref{cap:conceitos:compiladores}.
  E então apresentaremos um par de conceitos computacionais usados
  quando o código escrito em uma determinada linguagem é processado - na seção
  \ref{cap:conceitos:gramaticas} -, uma vez que o sistema que desenvolvemos lida
  com uma situação semelhante.

  \section{Linguagens de Programação}
  \label{cap:conceitos:linguagens}

  Conforme as pessoas percebem os padrões e os protocolos de um procedimento
  qualquer (como escovar os dentes ou dirigir um carro), elas tornam-se capazes
  de descrevê-lo de forma que outros possam reproduzí-lo. E acontece que alguns
  procedimentos (como calcular a média de um conjunto de números ou ordenar uma
  sequência de valores) podem ser descritos de maneira tão exata que podemos
  mandar computadores digitais realizá-los para nós. Dizemos que um processo
  assim é uma \textbf{computação}, pois ele trabalha estritamente sobre um
  \textbf{modelo computacional}.
  
  Em certo ponto, ao invés de ensinarmos um indivíduo a fazer algo, simplesmente
  escrevemos receitas e manuais que especificam como o procedimento deve ser
  feito. No caso dos computadores, isso significa fazer um \textbf{programa}
  que descreve as ações que a máquina deve executar. E da mesma maneira que
  escrevemos receitas e manuais usando uma linguagem natural (como Português ou
  Inglês), programas são expressos através de \textbf{linguagens de
  programação}.

  \definicao{
    De maneira mais formal, podemos definir os termos acima conforme
    \cite[Introduction]{pl:00}:
    \begin{enumerate}
      \item Um \textbf{modelo computacional} é uma coleção de valores e operações.
      \item Uma \textbf{computação} é a aplicação de um sequência de operações
            sobre um valor para obter outro valor.
      \item Um \textbf{programa} é a especificação de uma computação.
      \item Uma \textbf{linguagem de programação} é uma notação para escrever
            programas.
    \end{enumerate}
  }

  E com isso gostaríamos de esclarecer que quando dizemos ``integração entre
  linguagens de programação'' estamos fazendo um abuso de expressão que na
  verdade significa ``integração entre programas escritos em diferentes
  linguagens de programação''. E não ``composição de várias linguagens de
  programação em uma única linguagem''. Além disso, isso mostra que na realidade
  o usuário do nosso sistema estará lidando com \emph{múltiplos} programas que,
  por estarem integrados, comportam-se como se fossem um só.

  Como sabemos, existem inúmeras linguagens de programação. Ao longo dos anos,
  várias classificações foram surgindo como tentativa de diferenciar o
  propósito, o funcionamento e as vantagens de cada uma delas. Cada
  classificação leva em conta um aspecto diferente da linguagem. No que diz
  respeito a esse trabalho, estamos interessados em discriminar como os
  programas escritos nelas são usados para realizar as computações que eles
  representam. Em outras palavras, como essas linguagens fazem para ``rodar''
  seus programas. Entendendo esse mecanismo, saberemos \emph{se} e \emph{como} é
  possível interligar a execução de programas escritos em diferentes linguagens.

  \section{Compiladores e máquinas virtuais}
  \label{cap:conceitos:compiladores}

  A princípio, programas era implantados diretamente na máquina que os
  executaria, que conhecemos como \emph{computador}. Isso era feito de diversas
  maneiras, em geral envolvendo manipular fisicamente a máquina através de
  chaves ou cartões. Conforme os computadores foram ficando mais elaborados,
  tornou-se possível usar eles mesmos para escrever programas diretamente em
  sua memória. Como é de se esperar, eles eram escritos usando alguma linguagem
  de programação, como vimos na seção anterior.

  Ainda assim, escrever nessas primeiras linguagens envolvia usar apenas valores
  numéricos que representavam instruções explícitas do \emph{hardware} da
  máquina. Essas linguagens são chamadas de \textbf{código de máquina}. E cada
  modelo de computador tinha uma diferente, forçando o programador a aprender
  várias linguagens para ser capaz de desenvolver em diferentes ambientes. A
  solução para isso foram os \textbf{compiladores}: programas que processavam
  código escrito \emph{em alguma outra linguagem de programação} e escreviam
  o equivalente - segundo a semântica dessa linguagem - em código de máquina.

  \definicao{
    Juntando o que acabamos de ver, temos:
    \begin{enumerate}
      \item \textbf{Código de máquina} é toda linguagem de programação que é
            processada diretamente por uma máquina como um computador.
      \item Uma \textbf{linguagem de programação compilada} é uma linguagem cujo
            código é processado por um programa, chamado de \textbf{compilador},
            e traduzida para código de máquina.
    \end{enumerate}
  }

  As primeiras linguagens compiladas eram as \textbf{linguagens de montagem}. Os
  termos delas eram compostos de comando mnemônicos que em geral correspondiam
  diretamente ao código de máquina que eles representavam. Por exemplo o trecho

  \begin{verbatim}
    add ecx, edx\end{verbatim}

  \hspace{-16pt}é compilado para a sequência de valores numéricos que indicam,
  em código de máquina, a instrução de \emph{hardware} responsável por somar os
  valores nos registradores \lang{ecx} e \lang{edx}, escrevendo o resultado em
  um deles em seguida (isso depende da linguagem de montagem usada).

  Depois disso, outras linguagens foram sendo inventadas que cada vez mais
  permitiam ao programador abstrair as operações de \emph{hardware} por trás
  do código que ele escrevia. Isso passou a ser responsabilidade do compilador,
  que em certo ponto passou a ser capaz de até otimizar o código de máquina
  gerado ao detectar padrões conhecidos no que o programador fornecia através
  da linguagem compilada. Havia quem chamasse código de máquina e linguagens de
  montagem de \emph{linguagens de baixo nível}, e as demais linguagens
  compiladas de \emph{linguagens de alto nível}.

  % TODO: eficiência vs produtividade => justifica linguagens de alto nível.
  % TODO: linguagens de script que eram linguagens interpretadas.
  % TODO: linguagens de script que usam máquinas virtuais.
  % TODO: se vira ae para descobrir um jeito da hora de falar essas coisas

  \section{Gramáticas e analisadores léxico-sintáticos}
  \label{cap:conceitos:gramaticas}

