
\chapter{Conceitos e tecnologias estudadas}
\label{cap:conceitos}
  Sempre que encontramos um problema, buscamos uma solução. Muitos dos produtos
  que usamos diariamente são a manifestação dessas soluções que alguém projetou
  para lidar com os empecilhos do dia-a-dia, desde uma mobília para conseguirmos
  sentar e comer até aparelhos elaborados para detectar doenças em nossos
  corpos. Entender o problema que se quer resolver, e saber desprender a solução
  dessa análise é um procedimento fundamental ao projetar esses produtos -- o
  mesmo vale quando desenvolemos um \textit{software}. Para tanto, existem
  várias maneiras de se modelar os problemas, e uma das mais simples é na forma
  de um pergunta.

  \emph{Como integrar linguagens de programação?} Um dos primeiros
  conceitos com o qual aspirantes a programadores têm que se habituar é que
  programas são o resultado de um código misterioso escrito usando uma dessas
  chamadas linguagens de programação. A partir desse momento, costuma-se passar
  por aquele período onde se acredita que a quantidade de linguagens dominadas
  define uma métrica das habilidades do programador ou da programadora, e
  ficamos maravilhados pela miríade de linguagens diferentes. Até que entendemos
  que por trás de todas elas a ideia é relativamente a mesma, naquele momento em
  que percebemos que ``ah, então é assim que se faz um laço nessa linguagem''.
  
  Mas anedotas à parte, permanece o fato de que cada linguagem de programação
  funciona através do seu próprio mecanismo de implementação. Como seria
  possível qualquer tipo de integração entre elas, então? Esse capítulo tem
  como objetivo esclarecer essa questão, e com isso destacar o problema que
  o nosso sistema foi projetado para resolver, além do método necessário para
  tanto. Começamos tentando entender melhor o que são esses elementos que
  estamos tentando integrar.

  \section{Linguagens de Programação}
  \label{cap:conceitos:linguagens}
  Uma das coisas mais importantes que todo programador aprende cedo ou tarde é
  que computadores \emph{não são máquinas inteligentes}. Eles fazem apenas e
  exatamente aquilo que mandamos eles fazerem, a menos de problemas de
  \textit{hardware}. Por outro lado, é isso que torna eles mais confiáveis que
  humanos no que diz respeito a muitas atividades. E o que explica essa
  característica intrínsica dos computadores é que eles operam através de
  instruções.

  Em uma primeira instância não estamos interessados em como esse funcionamento
  ocorre, mas sim na ideia que está por trás dele. Quando recebemos uma
  instrução, tipicamente nos está sendo pedido para realizar uma ação,
  possivelmente envolvendo objetos ou outras pessoas. Com o computador, as ações
  que lhe são instruídas envolvem dados\footnotemark{}. As transformações e
  manipulações que ele pode executar sobre dados, assim como o que os dados
  podem representar compõem o que chamamos de \textbf{modelo computacional},
  pois indicam as possíveis \textbf{computações} que podem ser realizadas dentro
  de tal modelo. Por sua vez, dizemos que as intruções que especificam a
  computação que desejamos que o computador faça compõem um \textbf{programa}.
  Finalmente, isso leva ao nosso objeto de interesse: para expressar esse
  programa ao computador usamos uma \textbf{linguagem de programação}. De
  maneira mais formal, podemos definir os termos acima conforme
  \cite[Introduction]{pl:00}:
  
  \footnotetext{\cite[1.2 Structure and Function]{org&arch:00}.}

  \definicao{
    \begin{enumerate}
      \item Um \textbf{modelo computacional} é uma coleção de valores e operações.
      \item Uma \textbf{computação} é a aplicação de uma sequência de operações
            sobre um valor para obter outro valor.
      \item Um \textbf{programa} é a especificação de uma computação.
      \item Uma \textbf{linguagem de programação} é uma notação para escrever
            programas.
    \end{enumerate}
  }

  E com isso gostaríamos de esclarecer que quando dizemos ``integração entre
  linguagens de programação'' estamos fazendo um abuso de expressão que na
  verdade significa ``integração entre \emph{programas} escritos em diferentes
  linguagens de programação''. E não ``composição de várias linguagens de
  programação em uma única linguagem''. Além disso, isso mostra que na realidade
  o usuário do nosso sistema estará lidando com \emph{múltiplos} programas que,
  por estarem integrados, comportam-se como se fossem um só.

  Como sabemos, existem inúmeras linguagens de programação. Ao longo dos anos,
  várias classificações foram surgindo como tentativa de diferenciar o
  propósito, o funcionamento e as vantagens de cada uma delas. Cada
  classificação leva em conta um aspecto diferente da linguagem. No que diz
  respeito a esse trabalho, estamos interessados em discriminar como os
  programas escritos nelas são usados para realizar as computações que eles
  representam. Em outras palavras, como essas linguagens fazem para ``rodar''
  seus programas. Entendendo esse mecanismo, saberemos \emph{se} e \emph{como} é
  possível interligar a execução de programas escritos em diferentes linguagens.

  \section{Compiladores e máquinas virtuais}
  \label{cap:conceitos:compiladores}

    %TODO: Essa seção inteira precisa de referências!

    A princípio, programas era implantados diretamente na máquina que os
    executaria, que conhecemos como \emph{computador}. Isso era feito de diversas
    maneiras, em geral envolvendo manipular fisicamente a máquina através de
    chaves ou cartões. Conforme os computadores foram ficando mais elaborados,
    tornou-se possível usar eles mesmos para escrever programas diretamente em
    sua memória. Como é de se esperar, isso era feito usando alguma linguagem
    de programação, conforme vimos na seção anterior.

    Ainda assim, escrever nessas primeiras linguagens envolvia usar apenas valores
    numéricos que representavam instruções explícitas do \emph{hardware} da
    máquina. Essas linguagens são chamadas de \textbf{código de máquina}. E cada
    modelo de computador trabalhava com um código de máquina diferente (eles
    continuam assim até hoje), forçando o programador a aprender várias linguagens
    para ser capaz de desenvolver em diferentes ambientes. A solução para isso
    foram os \textbf{compiladores}: programas que processavam código escrito
    \emph{em alguma outra linguagem de programação} e escreviam o equivalente -
    segundo a semântica dessa linguagem - em código de máquina.

    \definicao{
      Juntando o que acabamos de ver, temos:
      \begin{enumerate}
        \item \textbf{Código de máquina} é toda linguagem de programação que é
              processada diretamente por uma máquina como um computador.
        \item Uma \textbf{linguagem de programação compilada} é uma linguagem cujo
              código é processado por um programa, chamado de \textbf{compilador},
              e traduzida para código de máquina.
      \end{enumerate}
    }

    As primeiras linguagens compiladas eram as \textbf{linguagens de montagem}. Os
    termos delas eram compostos de comando mnemônicos que em geral correspondiam
    diretamente ao código de máquina que eles representavam. Por exemplo o trecho

    \begin{verbatim}
      add ecx, edx\end{verbatim}

    \hspace{-16pt}é compilado para a sequência de valores numéricos que indicam,
    em código de máquina, a instrução de \emph{hardware} responsável por somar os
    valores nos registradores \lang{ecx} e \lang{edx}, escrevendo o resultado de
    volta em um deles em seguida (isso depende da linguagem de montagem usada).

    Depois disso, outras linguagens foram sendo inventadas que cada vez mais
    permitiam ao programador abstrair as operações de \emph{hardware} por trás
    do código que ele escrevia. Os responsáveis por essa tradução passaram a ser
    os compiladores. Em certo ponto else se tornaram capazes de até otimizar o
    código de máquina gerado ao detectar padrões conhecidos no que o programador
    fornecia através da linguagem compilada. Havia quem chamasse código de máquina
    e linguagens de montagem de \emph{linguagens de baixo nível}, e as demais
    linguagens compiladas de \emph{linguagens de alto nível}.

    % TODO: eficiência vs produtividade => justifica linguagens de alto nível.
    % TODO: linguagens de script que eram linguagens interpretadas.
    % TODO: linguagens de script que usam máquinas virtuais.
    % TODO: se vira ae para descobrir um jeito da hora de falar essas coisas

  \section{Gramáticas e analisadores léxico-sintáticos}
  \label{cap:conceitos:gramaticas}

    Isso será escrito na versão final da monografia.

