// FILE GENERATED BY OPWIG - OUROBOROS PROJECT.

#include <Python.h>
#include <languages/python/pythonmachine.h>
#include <languages/python/pythonconverter.h>
#include <languages/python/wrapperbase.h>
#include <opa/scriptmanager.h>
#include <opa/module.h>
#include <iostream>
#include <string>


#include <test.h>

using std::string;
using std::cout;
using std::endl;
using opa::Module;
using opa::python::PythonMachine;
using opa::python::PythonConverter;
using opa::python::wrapper::NumArgsOk;
using opa::python::wrapper::AddToParentModule;
using opa::python::wrapper::FuncErrorHandling;
using opa::python::wrapper::AddTypeToModule;

namespace opwig_py_generated {


PyObject* OPWIG_wrap_foo(PyObject* py_self, PyObject* args)
try {
    if (!NumArgsOk(args, 2)) return nullptr;
    PythonConverter converter (true);
    double fArg0 = converter.PyArgToType<double>(args, 0);
    double fArg1 = converter.PyArgToType<double>(args, 1);
    double fValue = ::foo(fArg0, fArg1);
    return converter.TypeToScript<double>(fValue);
}
catch (std::exception& e) { return FuncErrorHandling(e); }

PyObject* OPWIG_wrap_x(PyObject* self, PyObject* args)
try {
    PythonConverter converter (true);
    int oldValue = ::x;
    if (static_cast<int>(PyTuple_Size(args)) == 1) {
        ::x = converter.PyArgToType<int>(args, 0);
    }
    else if (!NumArgsOk(args, 0)) return nullptr;
    return converter.TypeToScript<int>(oldValue);
}
catch (std::exception& e) { return FuncErrorHandling(e); }


} //namespace opwig_py_generated

//module test method table
static PyMethodDef testMethods[] = {
    {"foo", opwig_py_generated::OPWIG_wrap_foo, METH_VARARGS, "calls C++ wrapped function" },
    {"x", opwig_py_generated::OPWIG_wrap_x, METH_VARARGS, "wraps C++ variable - call() for get, call(newValue) for set [if possible]" },
    {NULL, NULL, 0, NULL} //sentinel
};

PyMODINIT_FUNC
inittest(void) {
    Py_InitModule("test", testMethods);
}

namespace {

class Bootstrap final {
  public:
    Bootstrap ();
};

Bootstrap entry_point;

Bootstrap::Bootstrap () {
    cout << "Bootstrapping Python module test" << endl;
    PythonMachine *vm = dynamic_cast<PythonMachine*>(
        SCRIPT_MANAGER()->GetMachine("Python")
    );
    if (vm == NULL) {
        vm = new PythonMachine;
        SCRIPT_MANAGER()->Register(vm);
    }
    vm->RegisterModule(Module<void (*)(void)>("test", inittest));
}

} // unnamed namespace

